// Generated by typings
// Source: node_modules/aurelia-logging/dist/commonjs/aurelia-logging.d.ts
declare module '~aurelia-templating-resources~aurelia-logging/dist/commonjs/aurelia-logging' {
module 'aurelia-logging' {
  
  /**
  * Specifies the available logging levels.
  */
  export interface LogLevel {
    
    /**
      * No logging.
      */
    none: number;
    
    /**
      * Log only error messages.
      */
    error: number;
    
    /**
      * Log warnings messages or above.
      */
    warn: number;
    
    /**
      * Log informational messages or above.
      */
    info: number;
    
    /**
      * Log all messages.
      */
    debug: number;
  }
  
  /**
  * Implemented by classes which wish to append log data to a target data store.
  */
  export interface Appender {
    
    /**
      * Appends a debug log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    debug(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends an info log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    info(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends a warning log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    warn(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends an error log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    error(logger: Logger, ...rest: any[]): void;
  }
  
  /**
  * Specifies the available logging levels.
  */
  /**
  * Specifies the available logging levels.
  */
  export const logLevel: LogLevel;
  
  /**
  * Gets the instance of a logger associated with a particular id (or creates one if it doesn't already exist).
  *
  * @param id The id of the logger you wish to get an instance of.
  * @return The instance of the logger, or creates a new logger if none exists for that id.
  */
  export function getLogger(id: string): Logger;
  
  /**
  * Adds an appender capable of processing logs and channeling them to an output.
  *
  * @param appender An appender instance to begin processing logs with.
  */
  /**
  * Adds an appender capable of processing logs and channeling them to an output.
  *
  * @param appender An appender instance to begin processing logs with.
  */
  export function addAppender(appender: Appender): void;
  
  /**
  * Sets the level of logging for the application loggers.
  *
  * @param level Matches a value of logLevel specifying the level of logging.
  */
  export function setLevel(level: number): void;
  
  /**
  * A logger logs messages to a set of appenders, depending on the log level that is set.
  */
  export class Logger {
    
    /**
      * The id that the logger was created with.
      */
    id: string;
    
    /**
      * You cannot instantiate the logger directly - you must use the getLogger method instead.
      */
    constructor(id: string, key: Object);
    
    /**
       * Logs a debug message.
       *
       * @param message The message to log.
       */
    debug(message: string): void;
    
    /**
       * Logs info.
       *
       * @param message The message to log.
       */
    info(message: string): void;
    
    /**
       * Logs a warning.
       *
       * @param message The message to log.
       */
    warn(message: string): void;
    
    /**
       * Logs an error.
       *
       * @param message The message to log.
       */
    error(message: string): void;
  }
}
}
declare module 'aurelia-logging' {
export * from '~aurelia-templating-resources~aurelia-logging/dist/commonjs/aurelia-logging';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection.d.ts
declare module '~aurelia-templating-resources~aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection' {
module 'aurelia-dependency-injection' {
  import {
    protocol,
    metadata
  } from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-metadata';
  import {
    AggregateError
  } from '~aurelia-templating-resources~aurelia-dependency-injection~aurelia-pal';
  
  /**
  * Used to allow functions/classes to specify custom dependency resolution logic.
  */
  export interface Resolver {
    
    /**
      * Called by the container to allow custom resolution of dependencies for a function/class.
      * @param container The container to resolve from.
      * @param key The key that the resolver was registered as.
      * @return Returns the resolved object.
      */
    get(container: Container, key: any): any;
  }
  
  /**
  * A strategy for invoking a function, resulting in an object instance.
  */
  export interface Invoker {
    
    /**
      * Invokes the function with the provided dependencies.
      * @param fn The constructor or factory function.
      * @param dependencies The dependencies of the function call.
      * @return The result of the function invocation.
      */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param fn The constructor or factory function.
      * @param staticDependencies The static dependencies of the function.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
  }
  
  /**
  * Customizes how a particular function is resolved by the Container.
  */
  export interface Registration {
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Used to configure a Container instance.
  */
  export interface ContainerConfiguration {
    
    /**
      * An optional callback which will be called when any function needs an InvocationHandler created (called once per Function).
      */
    onHandlerCreated?: (handler: InvocationHandler) => InvocationHandler;
  }
  
  /**
  * Decorator: Indicates that the decorated class/object is a custom resolver.
  */
  export const resolver: Function;
  
  /**
  * Used to allow functions/classes to specify lazy resolution logic.
  */
  
  /**
  * Used to allow functions/classes to specify lazy resolution logic.
  */
  export class Lazy {
    
    /**
      * Creates an instance of the Lazy class.
      * @param key The key to lazily resolve.
      */
    constructor(key: any);
    
    /**
      * Called by the container to lazily resolve the dependency into a lazy locator function.
      * @param container The container to resolve from.
      * @return Returns a function which can be invoked at a later time to obtain the actual dependency.
      */
    get(container: Container): any;
    
    /**
      * Creates a Lazy Resolver for the supplied key.
      * @param key The key to lazily resolve.
      * @return Returns an instance of Lazy for the key.
      */
    static of(key: any): Lazy;
  }
  
  /**
  * Used to allow functions/classes to specify resolution of all matches to a key.
  */
  export class All {
    
    /**
      * Creates an instance of the All class.
      * @param key The key to lazily resolve all matches for.
      */
    constructor(key: any);
    
    /**
      * Called by the container to resolve all matching dependencies as an array of instances.
      * @param container The container to resolve from.
      * @return Returns an array of all matching instances.
      */
    get(container: Container): any[];
    
    /**
      * Creates an All Resolver for the supplied key.
      * @param key The key to resolve all instances for.
      * @return Returns an instance of All for the key.
      */
    static of(key: any): All;
  }
  
  /**
  * Used to allow functions/classes to specify an optional dependency, which will be resolved only if already registred with the container.
  */
  export class Optional {
    
    /**
      * Creates an instance of the Optional class.
      * @param key The key to optionally resolve for.
      * @param checkParent Indicates whether or not the parent container hierarchy should be checked.
      */
    constructor(key: any, checkParent?: boolean);
    
    /**
      * Called by the container to provide optional resolution of the key.
      * @param container The container to resolve from.
      * @return Returns the instance if found; otherwise null.
      */
    get(container: Container): any;
    
    /**
      * Creates an Optional Resolver for the supplied key.
      * @param key The key to optionally resolve for.
      * @param [checkParent=false] Indicates whether or not the parent container hierarchy should be checked.
      * @return Returns an instance of Optional for the key.
      */
    static of(key: any, checkParent?: boolean): Optional;
  }
  
  /**
  * Used to inject the dependency from the parent container instead of the current one.
  */
  export class Parent {
    
    /**
      * Creates an instance of the Parent class.
      * @param key The key to resolve from the parent container.
      */
    constructor(key: any);
    
    /**
      * Called by the container to load the dependency from the parent container
      * @param container The container to resolve the parent from.
      * @return Returns the matching instance from the parent container
      */
    get(container: Container): any;
    
    /**
      * Creates a Parent Resolver for the supplied key.
      * @param key The key to resolve.
      * @return Returns an instance of Parent for the key.
      */
    static of(key: any): Parent;
  }
  export class StrategyResolver {
    
    /**
      * Creates an instance of the StrategyResolver class.
      * @param strategy The type of resolution strategy.
      * @param state The state associated with the resolution strategy.
      */
    constructor(strategy: any, state: any);
    
    /**
      * Called by the container to allow custom resolution of dependencies for a function/class.
      * @param container The container to resolve from.
      * @param key The key that the resolver was registered as.
      * @return Returns the resolved object.
      */
    get(container: Container, key: any): any;
  }
  
  /**
  * Used to allow injecting dependencies but also passing data to the constructor.
  */
  export class Factory {
    
    /**
      * Creates an instance of the Factory class.
      * @param key The key to resolve from the parent container.
      */
    constructor(key: any);
    
    /**
      * Called by the container to pass the dependencies to the constructor.
      * @param container The container to invoke the constructor with dependencies and other parameters.
      * @return Returns a function that can be invoked to resolve dependencies later, and the rest of the parameters.
      */
    get(container: Container): any;
    
    /**
      * Creates a Factory Resolver for the supplied key.
      * @param key The key to resolve.
      * @return Returns an instance of Factory for the key.
      */
    static of(key: any): Factory;
  }
  
  /**
  * Decorator: Specifies a custom Invoker for the decorated item.
  */
  export function invoker(value: Invoker): any;
  
  /**
  * Decorator: Specifies that the decorated item should be called as a factory function, rather than a constructor.
  */
  export function factory(potentialTarget?: any): any;
  
  /**
  * An Invoker that is used to invoke a factory method.
  */
  /**
  * An Invoker that is used to invoke a factory method.
  */
  export class FactoryInvoker {
    
    /**
      * The singleton instance of the FactoryInvoker.
      */
    static instance: FactoryInvoker;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param container The calling container.
      * @param fn The constructor or factory function.
      * @param dependencies The dependencies of the function call.
      * @return The result of the function invocation.
      */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param container The calling container.
      * @param fn The constructor or factory function.
      * @param staticDependencies The static dependencies of the function.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
  }
  
  /**
  * Decorator: Specifies a custom registration strategy for the decorated class/function.
  */
  export function registration(value: Registration): any;
  
  /**
  * Decorator: Specifies to register the decorated item with a "transient" lifetime.
  */
  export function transient(key?: any): any;
  
  /**
  * Decorator: Specifies to register the decorated item with a "singleton" lieftime.
  */
  export function singleton(keyOrRegisterInChild?: any, registerInChild?: boolean): any;
  
  /**
  * Used to allow functions/classes to indicate that they should be registered as transients with the container.
  */
  /**
  * Used to allow functions/classes to indicate that they should be registered as transients with the container.
  */
  export class TransientRegistration {
    
    /**
      * Creates an instance of TransientRegistration.
      * @param key The key to register as.
      */
    constructor(key?: any);
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Used to allow functions/classes to indicate that they should be registered as singletons with the container.
  */
  export class SingletonRegistration {
    
    /**
      * Creates an instance of SingletonRegistration.
      * @param key The key to register as.
      */
    constructor(keyOrRegisterInChild?: any, registerInChild?: boolean);
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Stores the information needed to invoke a function.
  */
  export class InvocationHandler {
    
    /**
      * The function to be invoked by this handler.
      */
    fn: Function;
    
    /**
      * The invoker implementation that will be used to actually invoke the function.
      */
    invoker: Invoker;
    
    /**
      * The statically known dependencies of this function invocation.
      */
    dependencies: any[];
    
    /**
      * Instantiates an InvocationDescription.
      * @param fn The Function described by this description object.
      * @param invoker The strategy for invoking the function.
      * @param dependencies The static dependencies of the function call.
      */
    constructor(fn: Function, invoker: Invoker, dependencies: any[]);
    
    /**
      * Invokes the function.
      * @param container The calling container.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invoke(container: Container, dynamicDependencies?: any[]): any;
  }
  
  /**
  * A lightweight, extensible dependency injection container.
  */
  export class Container {
    
    /**
      * The global root Container instance. Available if makeGlobal() has been called. Aurelia Framework calls makeGlobal().
      */
    static instance: Container;
    
    /**
      * The parent container in the DI hierarchy.
      */
    parent: Container;
    
    /**
      * The root container in the DI hierarchy.
      */
    root: Container;
    
    /**
      * Creates an instance of Container.
      * @param configuration Provides some configuration for the new Container instance.
      */
    constructor(configuration?: ContainerConfiguration);
    
    /**
      * Makes this container instance globally reachable through Container.instance.
      */
    makeGlobal(): Container;
    
    /**
      * Sets an invocation handler creation callback that will be called when new InvocationsHandlers are created (called once per Function).
      * @param onHandlerCreated The callback to be called when an InvocationsHandler is created.
      */
    setHandlerCreatedCallback(onHandlerCreated: ((handler: InvocationHandler) => InvocationHandler)): any;
    
    /**
      * Registers an existing object instance with the container.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param instance The instance that will be resolved when the key is matched.
      */
    registerInstance(key: any, instance?: any): void;
    
    /**
      * Registers a type (constructor function) such that the container always returns the same instance for each request.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param [fn] The constructor function to use when the dependency needs to be instantiated.
      */
    registerSingleton(key: any, fn?: Function): void;
    
    /**
      * Registers a type (constructor function) such that the container returns a new instance for each request.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param [fn] The constructor function to use when the dependency needs to be instantiated.
      */
    registerTransient(key: any, fn?: Function): void;
    
    /**
      * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param handler The resolution function to use when the dependency is needed.
      */
    registerHandler(key: any, handler: ((container?: Container, key?: any, resolver?: Resolver) => any)): void;
    
    /**
      * Registers an additional key that serves as an alias to the original DI key.
      * @param originalKey The key that originally identified the dependency; usually a constructor function.
      * @param aliasKey An alternate key which can also be used to resolve the same dependency  as the original.
      */
    registerAlias(originalKey: any, aliasKey: any): void;
    
    /**
      * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param resolver The resolver to use when the dependency is needed.
      */
    registerResolver(key: any, resolver: Resolver): void;
    
    /**
      * Registers a type (constructor function) by inspecting its registration annotations. If none are found, then the default singleton registration is used.
      * @param fn The constructor function to use when the dependency needs to be instantiated.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      */
    autoRegister(fn: any, key?: any): Resolver;
    
    /**
      * Registers an array of types (constructor functions) by inspecting their registration annotations. If none are found, then the default singleton registration is used.
      * @param fns The constructor function to use when the dependency needs to be instantiated.
      */
    autoRegisterAll(fns: any[]): void;
    
    /**
      * Unregisters based on key.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      */
    unregister(key: any): void;
    
    /**
      * Inspects the container to determine if a particular key has been registred.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param checkParent Indicates whether or not to check the parent container hierarchy.
      * @return Returns true if the key has been registred; false otherwise.
      */
    hasResolver(key: any, checkParent?: boolean): boolean;
    
    /**
      * Resolves a single instance based on the provided key.
      * @param key The key that identifies the object to resolve.
      * @return Returns the resolved instance.
      */
    get(key: any): any;
    
    /**
      * Resolves all instance registered under the provided key.
      * @param key The key that identifies the objects to resolve.
      * @return Returns an array of the resolved instances.
      */
    getAll(key: any): any[];
    
    /**
      * Creates a new dependency injection container whose parent is the current container.
      * @return Returns a new container instance parented to this.
      */
    createChild(): Container;
    
    /**
      * Invokes a function, recursively resolving its dependencies.
      * @param fn The function to invoke with the auto-resolved dependencies.
      * @param dynamicDependencies Additional function dependencies to use during invocation.
      * @return Returns the instance resulting from calling the function.
      */
    invoke(fn: Function, dynamicDependencies?: any[]): any;
  }
  
  /**
  * Decorator: Directs the TypeScript transpiler to write-out type metadata for the decorated class.
  */
  export function autoinject(potentialTarget?: any): any;
  
  /**
  * Decorator: Specifies the dependencies that should be injected by the DI Container into the decoratored class/function.
  */
  export function inject(...rest: any[]): any;
}
}
declare module 'aurelia-dependency-injection' {
export * from '~aurelia-templating-resources~aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection';
}

// Generated by typings
// Source: node_modules/aurelia-logging/dist/commonjs/aurelia-logging.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-logging/dist/commonjs/aurelia-logging' {
module 'aurelia-logging' {
  
  /**
  * Specifies the available logging levels.
  */
  export interface LogLevel {
    
    /**
      * No logging.
      */
    none: number;
    
    /**
      * Log only error messages.
      */
    error: number;
    
    /**
      * Log warnings messages or above.
      */
    warn: number;
    
    /**
      * Log informational messages or above.
      */
    info: number;
    
    /**
      * Log all messages.
      */
    debug: number;
  }
  
  /**
  * Implemented by classes which wish to append log data to a target data store.
  */
  export interface Appender {
    
    /**
      * Appends a debug log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    debug(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends an info log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    info(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends a warning log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    warn(logger: Logger, ...rest: any[]): void;
    
    /**
      * Appends an error log.
      *
      * @param logger The source logger.
      * @param rest The data to log.
      */
    error(logger: Logger, ...rest: any[]): void;
  }
  
  /**
  * Specifies the available logging levels.
  */
  /**
  * Specifies the available logging levels.
  */
  export const logLevel: LogLevel;
  
  /**
  * Gets the instance of a logger associated with a particular id (or creates one if it doesn't already exist).
  *
  * @param id The id of the logger you wish to get an instance of.
  * @return The instance of the logger, or creates a new logger if none exists for that id.
  */
  export function getLogger(id: string): Logger;
  
  /**
  * Adds an appender capable of processing logs and channeling them to an output.
  *
  * @param appender An appender instance to begin processing logs with.
  */
  /**
  * Adds an appender capable of processing logs and channeling them to an output.
  *
  * @param appender An appender instance to begin processing logs with.
  */
  export function addAppender(appender: Appender): void;
  
  /**
  * Sets the level of logging for the application loggers.
  *
  * @param level Matches a value of logLevel specifying the level of logging.
  */
  export function setLevel(level: number): void;
  
  /**
  * A logger logs messages to a set of appenders, depending on the log level that is set.
  */
  export class Logger {
    
    /**
      * The id that the logger was created with.
      */
    id: string;
    
    /**
      * You cannot instantiate the logger directly - you must use the getLogger method instead.
      */
    constructor(id: string, key: Object);
    
    /**
       * Logs a debug message.
       *
       * @param message The message to log.
       */
    debug(message: string): void;
    
    /**
       * Logs info.
       *
       * @param message The message to log.
       */
    info(message: string): void;
    
    /**
       * Logs a warning.
       *
       * @param message The message to log.
       */
    warn(message: string): void;
    
    /**
       * Logs an error.
       *
       * @param message The message to log.
       */
    error(message: string): void;
  }
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-logging' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-logging/dist/commonjs/aurelia-logging';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-path/dist/commonjs/aurelia-path.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-path/dist/commonjs/aurelia-path' {
module 'aurelia-path' {
  
  /**
  * Calcualtes a path relative to a file.
  *
  * @param name The relative path.
  * @param file The file path.
  * @return The calcualted path.
  */
  export function relativeToFile(name: string, file: string): string;
  
  /**
  * Joins two paths.
  *
  * @param path1 The first path.
  * @param path2 The second path.
  * @return The joined path.
  */
  export function join(path1: string, path2: string): string;
  
  /**
  * Generate a query string from an object.
  *
  * @param params Object containing the keys and values to be used.
  * @returns The generated query string, excluding leading '?'.
  */
  export function buildQueryString(params: Object): string;
  
  /**
  * Parse a query string.
  *
  * @param queryString The query string to parse.
  * @returns Object with keys and values mapped from the query string.
  */
  export function parseQueryString(queryString: string): Object;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-path' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-path/dist/commonjs/aurelia-path';
}

// Generated by typings
// Source: node_modules/aurelia-path/dist/commonjs/aurelia-path.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-path/dist/commonjs/aurelia-path' {
module 'aurelia-path' {
  
  /**
  * Calcualtes a path relative to a file.
  *
  * @param name The relative path.
  * @param file The file path.
  * @return The calcualted path.
  */
  export function relativeToFile(name: string, file: string): string;
  
  /**
  * Joins two paths.
  *
  * @param path1 The first path.
  * @param path2 The second path.
  * @return The joined path.
  */
  export function join(path1: string, path2: string): string;
  
  /**
  * Generate a query string from an object.
  *
  * @param params Object containing the keys and values to be used.
  * @returns The generated query string, excluding leading '?'.
  */
  export function buildQueryString(params: Object): string;
  
  /**
  * Parse a query string.
  *
  * @param queryString The query string to parse.
  * @returns Object with keys and values mapped from the query string.
  */
  export function parseQueryString(queryString: string): Object;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-path' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-path/dist/commonjs/aurelia-path';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-loader/dist/commonjs/aurelia-loader.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader/dist/commonjs/aurelia-loader' {
module 'aurelia-loader' {
  import {
    relativeToFile
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-path';
  import {
    Origin
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-loader~aurelia-metadata';
  
  /*eslint no-unused-vars:0*/
  /**
  * Represents a plugin to the module loader.
  */
  export interface LoaderPlugin {
    
    /**
      * Fetches the resource.
      * @param address The address of the resource.
      * @return A Promise for the requested resouce.
      */
    fetch(address: string): Promise<any>;
  }
  
  /**
  * Represents a dependency of a template.
  */
  export class TemplateDependency {
    
    /**
      * The source of the dependency.
      */
    src: string;
    
    /**
      * The local name of the src when used in the template.
      */
    name: string;
    
    /**
      * Creates a template dependency.
      * @param src The source of the dependency.
      * @param name The local name of the src when used in the template.
      */
    constructor(src: string, name?: string);
  }
  
  /**
  * Represents an entry in the template registry.
  */
  export class TemplateRegistryEntry {
    
    /**
      * The address of the template that this entry represents.
      */
    address: string;
    
    /**
      * Indicates whether or not the associated template is loaded .
      */
    templateIsLoaded: boolean;
    
    /**
      * Indicates whether the factory is ready to be used to create instances of the associated template.
      */
    factoryIsReady: boolean;
    
    /**
      * Sets the resources associated with this entry.
      */
    resources: Object;
    
    /**
      * The dependencies of the associated template. Dependencies are not available until after the template is loaded.
      */
    dependencies: TemplateDependency[];
    
    /**
      * Creates an instance of TemplateRegistryEntry.
      * @param address The address of the template that this entry represents.
      */
    constructor(address: string);
    
    /**
      * Gets the template for this registry entry.
      */
    template: Element;
    
    /**
      * Gets the factory capable of creating instances of this template.
      */
    factory: any;
    
    /**
      * Adds a dependency to this template registry entry. Cannot be called until after the template is set.
      * @param src The dependency instance or a relative path to its module.
      * @param name An optional local name by which this dependency is used in the template.
      */
    addDependency(src: string | Function, name?: string): void;
  }
  
  /**
  * A generic resource loader, for loading modules, html, css and more.
  */
  /**
  * A generic resource loader, for loading modules, html, css and more.
  */
  export class Loader {
    
    /**
      * Creates an instance of Loader.
      */
    constructor();
    
    /**
      * Maps a module id to a source.
      * @param id The module id.
      * @param source The source to map the module to.
      */
    map(id: string, source: string): void;
    
    /**
      * Normalizes a module id.
      * @param moduleId The module id to normalize.
      * @param relativeTo What the module id should be normalized relative to.
      * @return The normalized module id.
      */
    normalizeSync(moduleId: string, relativeTo: string): string;
    
    /**
      * Normalizes a module id.
      * @param moduleId The module id to normalize.
      * @param relativeTo What the module id should be normalized relative to.
      * @return A promise for the normalized module id.
      */
    normalize(moduleId: string, relativeTo: string): Promise<string>;
    
    /**
      * Loads a module.
      * @param id The module id to normalize.
      * @return A Promise for the loaded module.
      */
    loadModule(id: string): Promise<any>;
    
    /**
      * Loads a collection of modules.
      * @param ids The set of module ids to load.
      * @return A Promise for an array of loaded modules.
      */
    loadAllModules(ids: string[]): Promise<any[]>;
    
    /**
      * Loads a template.
      * @param url The url of the template to load.
      * @return A Promise for a TemplateRegistryEntry containing the template.
      */
    loadTemplate(url: string): Promise<TemplateRegistryEntry>;
    
    /**
      * Loads a text-based resource.
      * @param url The url of the text file to load.
      * @return A Promise for text content.
      */
    loadText(url: string): Promise<string>;
    
    /**
      * Alters a module id so that it includes a plugin loader.
      * @param url The url of the module to load.
      * @param pluginName The plugin to apply to the module id.
      * @return The plugin-based module id.
      */
    applyPluginToUrl(url: string, pluginName: string): string;
    
    /**
      * Registers a plugin with the loader.
      * @param pluginName The name of the plugin.
      * @param implementation The plugin implementation.
      */
    addPlugin(pluginName: string, implementation: LoaderPlugin): void;
    
    /**
      * Gets or creates a TemplateRegistryEntry for the provided address.
      * @param address The address of the template.
      * @return The located or created TemplateRegistryEntry.
      */
    getOrCreateTemplateRegistryEntry(address: string): TemplateRegistryEntry;
  }
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-loader' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-loader/dist/commonjs/aurelia-loader';
}

// Generated by typings
// Source: node_modules/aurelia-binding/dist/commonjs/aurelia-binding.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-binding/dist/commonjs/aurelia-binding' {
/**
 * A modern databinding library for JavaScript and HTML.
 */
module 'aurelia-binding' {
  import { Container } from 'aurelia-dependency-injection';

  /**
   * The "parallel" or "artificial" aspect of the binding scope. Provides access to the parent binding
   * context and stores contextual bindable members such as $event, $index, $odd, etc. Members on this
   * object take precedence over members of the bindingContext object.
   */
  export interface OverrideContext {
    parentOverrideContext: OverrideContext;
    bindingContext: any;
  }

  /**
   * The two part binding scope. The first part is the bindingContext which represents the primary scope, typically a
   * view-model instance and second the overrideContext
   */
  export interface Scope {
    /**
     * The primary aspect of the binding scope.  Typically a view-model instance.
     */
    bindingContext: any;
    /**
     * The "parallel" or "artificial" aspect of the binding scope. Provides access to the parent binding
     * context and stores contextual bindable members such as $event, $index, $odd, etc. Members on this
     * object take precedence over members of the bindingContext object.
     */
    overrideContext: OverrideContext;
  }

  /**
   * Provides a mechanism for releasing resources.
   */
  export interface Disposable {
    /**
     * Performs tasks associated with freeing, releasing, or resetting resources.
     */
    dispose(): void;
  }

  /**
   * Creates an overrideContext object with the supplied bindingContext and optional parent overrideContext.
   */
  export function createOverrideContext(bindingContext: any, parentOverrideContext?: OverrideContext): OverrideContext;

  /**
   * Creates a scope object for testing purposes.
   */
  export function createScopeForTest(bindingContext: any, parentBindingContext?: any): Scope;

  /**
   * A ValueConverter resource.
   */
  export class ValueConverterResource {
    static convention(name: string): ValueConverterResource;
    constructor(name: string);
    initialize(container: Container, target: any): void;
    register(registry: any, name: string): void;
  }

  /**
   * A BindingBehavior resource.
   */
  export class BindingBehaviorResource {
    static convention(name: string): BindingBehaviorResource;
    constructor(name: string);
    initialize(container: Container, target: any): void;
    register(registry: any, name: string): void;
  }

  /**
   * Decorator: Adds efficient subscription management methods to the decorated class's prototype.
   */
  export function subscriberCollection(): any;

  /**
   * Subscribes to appropriate element events based on the element property
   * being observed for changes.
   * This is an internal API and is subject to change without notice in future releases.
   */
  export class EventManager {
    registerElementConfig(config: { tagName: string; properties: { (s: string): string[] }; }): void;
    /**
     * Subscribes to specified event on the target element.
     * @param target Target element.
     * @param targetEvent Name of event to subscribe.
     * @param callback Event listener callback.
     * @param delegate True to use event delegation mechanism.
     * @returns function wich removes event listener.
     */
    addEventListener(target: Element, targetEvent: string, callback: (event: Event) => any, delegate: boolean): () => void;
  }

  /**
   * Observes property changes.
   */
  export interface PropertyObserver {
    /**
     * Subscribe to property change events.
     */
    subscribe(callback: (newValue: any, oldValue: any) => void): Disposable;
  }

  /**
   * Observes collection mutation.
   */
  export interface CollectionObserver {
    /**
     * Subscribe to collection mutation events.
     */
    subscribe(callback: (changeRecords: any) => void): Disposable;
  }

  /**
   * Describes the direction of the data flow in a binding.
   */
  export enum bindingMode {
    /**
     * Updates the binding target once. This is essentially a simpler form of one-way binding
     * that provides better performance in cases where the source value does not change.
     */
    oneTime = 0,
    /**
     * Updates the binding target (target) property when the binding source (source) changes.
     * This type of binding is appropriate if the element being bound is implicitly read-only.
     * If there is no need to monitor the changes of the target property, using the OneWay
     * binding mode avoids the overhead of the two-way binding mode.
     */
    oneWay = 1,
    /**
     * Causes changes to either the source property or the target property to automatically update
     * the other. This type of binding is appropriate for editable forms or other fully-interactive
     * UI scenarios.
     */
    twoWay = 2
  }

  /**
   * Lookup functions for value converter and binding behavior resources.
   */
  export interface LookupFunctions {
    bindingBehaviors(name: string): any;
    valueConverters(name: string): any;
  }

  /**
   * A callable object.
   */
  export interface Callable {
    call(context: any, newValue: any, oldValue: any): void;
    call(context: any, changeRecords: any): void;
  }

  /**
   * Observes property changes.
   */
  export interface InternalPropertyObserver {
    /**
     * Gets the property value.
     */
    getValue(): any;
    /**
     * Sets the property value.
     */
    setValue(newValue: any): void;
    /**
     * Subscribe to property changes with a callback function.
     */
    subscribe(callback: (newValue: any, oldValue: any) => void): void;
    /**
     * Subscribe a callable object to property changes.
     * @param context A value to be passed to the callable object's call function when a property change occurs.
     * @param callable A callable object.
     */
    subscribe(context: any, callable: Callable): void;
    /**
     * Unsubscribes a callback function from property changes.
     */
    unsubscribe(callback: (newValue: any, oldValue: any) => void): void;
    /**
     * Unsubscribes a callable object from property changes.
     * @param context A value to be passed to the callable object's call function when a property change occurs.
     * @param callable A callable object.
     */
    unsubscribe(context: any, callable: Callable): void;
  }

  /**
   * Observes collection mutation.
   */
  export interface InternalCollectionObserver {
    /**
     * Subscribe to collection mutation events with a callback function.
     */
    subscribe(callback: (changeRecords: any) => void): void;
    /**
     * Subscribe a callable object to collection mutation events.
     * @param context A value to be passed to the callable object's call function when collection mutation occurs.
     * @param callable A callable object.
     */
    subscribe(context: any, callable: Callable): void;
    /**
     * Unsubscribes a callback function from collection mutation changes.
     */
    unsubscribe(callback: (changeRecords: any) => void): void;
    /**
     * Unsubscribes a callable object from collection mutation events.
     * @param context A value to be passed to the callable object's call function when collection mutation occurs.
     * @param callable A callable object.
     */
    unsubscribe(context: any, callable: Callable): void;
  }

  /**
   * Provides high-level access to the definition of a binding, which connects the properties of
   * binding target objects (typically, HTML elements), and any data source
   */
  export interface Binding {
    /**
     * The directionality of the binding.
     */
    mode?: bindingMode;
    /**
     * The expression to access/assign/connect the binding source property.
     */
    sourceExpression?: Expression;
    /**
     * Assigns a value to the target.
     */
    updateTarget?: (value: any) => void;
    /**
     * Assigns a value to the source.
     */
    updateSource?: (value: any) => void;
    /**
     * Calls the source method with the specified args object.
     */
    callSource?: (event: any) => any;
    /**
     * Connects the binding to a scope.
     */
    bind(source: Scope): void;
    /**
     * Disconnects the binding from a scope.
     */
    unbind(): void;
  }

  /**
   * A factory for binding instances.
   */
  export interface BindingExpression {
    createBinding(target: any): Binding;
  }

  /**
   * Provides the base class from which the classes that represent expression tree nodes are derived.
   */
  export interface Expression {
    /**
     * Evaluates the expression using the provided scope and lookup functions.
     */
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    /**
     * Assigns a value to the property represented by the expression.
     */
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    /**
     * Subscribes a binding instance to the property change events along the path of the expression.
     */
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * A binding behavior expression.
   */
  export class BindingBehavior implements Expression {
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * A value converter expression.
   */
  export class ValueConverter implements Expression {
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * Parses strings containing javascript expressions and returns a data-binding specialized AST.
   */
  export class Parser {
    /**
     * Parses a string containing a javascript expression and returns a data-binding specialized AST. Memoized.
     */
    parse(input: string): Expression;
  }

  /**
   * Provides efficient property observers for properties that would otherwise require dirty-checking.
   */
  export interface ObjectObservationAdapter {
    getObserver(object: any, propertyName: string, descriptor: PropertyDescriptor): InternalPropertyObserver;
  }

  /**
   * Internal object observation API. Locates observers for properties, arrays and maps using a variety of strategies.
   */
  export class ObserverLocator {
    /**
     * Gets an observer for property changes.
     */
    getObserver(obj: any, propertyName: string): InternalPropertyObserver;
    /**
     * Adds a property observation adapter.
     */
    addAdapter(adapter: ObjectObservationAdapter): void;
    /**
     * Gets an observer for array mutation.
     */
    getArrayObserver(array: Array<any>): InternalCollectionObserver;
    /**
     * Gets an observer for map mutation.
     */
    getMapObserver(map: Map<any, any>): InternalCollectionObserver;
  }

  /**
   * Binding system API.
   */
  export class BindingEngine {
    /**
     * Creates a binding expression for the specified target property and source expression.
     * @param targetProperty The target attribute, eg "value" / "checked" / "textcontent" / "data-foo".
     * @param sourceExpression A javascript expression accessing the source property.
     * @param mode The directionality of the binding.
     * @param lookupFunctions Lookup functions for value converter and binding behavior resources.
     */
    createBindingExpression(targetProperty: string, sourceExpression: string, mode?: bindingMode, lookupFunctions?: LookupFunctions): BindingExpression;
    /**
     * Gets an observer for property changes.
     */
    propertyObserver(obj: Object, propertyName: string): PropertyObserver;
    /**
     * Gets an observer for collection mutation.
     */
    collectionObserver(collection: Array<any> | Map<any, any>): CollectionObserver;
    /**
     * Gets an observer for a javascript expression that accesses a property on the binding context.
     * @param bindingContext The binding context (view-model)
     * @param expression A javascript expression accessing the source property.
     */
    expressionObserver(bindingContext: any, expression: string): PropertyObserver;
    /**
     * Parses a string containing a javascript expression and returns a data-binding specialized AST. Memoized.
     */
    parseExpression(expression: string): Expression;
    /**
     * Registers an adapter that provides an efficient property observeration strategy for
     * properties that would otherwise require dirty-checking.
     */
    registerAdapter(adapter: ObjectObservationAdapter): void;
  }

  /**
   * Returns whether a property's dependencies have been declared.
   */
  export function hasDeclaredDependencies(descriptor: PropertyDescriptor): boolean;

  /**
   * Declares a property's dependencies.
   */
  export function declarePropertyDependencies(ctor: any, propertyName: string, dependencies: string[]): void;

 /**
  * Decorator: Indicates that the decorated property is computed from other properties.
  * @param propertyNames The names of the properties the decorated property is computed from.  Simple property names, not expressions.
  */
  export function computedFrom(...propertyNames: string[]): any;

 /**
  * Decorator: Indicates that the decorated class is a value converter.
  * @param name The name of the value converter.
  */
  export function valueConverter(name: string): any;

 /**
  * Decorator: Indicates that the decorated class is a binding behavior.
  * @param name The name of the binding behavior.
  */
  export function bindingBehavior(name: string): any;

  /**
   * A context used when invoking a binding's callable API to notify
   * the binding that the context is a "source update".
   */
  export const sourceContext: string;

  /**
   * An internal API used by Aurelia's array observation components.
   */
  export function getChangeRecords(): any;

  /**
   * An internal API used by Aurelia's array observation components.
   */
  export function mergeSplice(splices: any, index: number, removed: any, addedCount: number): any;
  
  /**
  * Decorator: Specifies that a property is observable.
  * @param targetOrConfig The name of the property, or a configuration object.
  */
  export function observable(targetOrConfig?: Object, key?: any, descriptor?: any): any;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-binding' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-binding/dist/commonjs/aurelia-binding';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection' {
module 'aurelia-dependency-injection' {
  import {
    protocol,
    metadata
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-metadata';
  import {
    AggregateError
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection~aurelia-pal';
  
  /**
  * Used to allow functions/classes to specify custom dependency resolution logic.
  */
  export interface Resolver {
    
    /**
      * Called by the container to allow custom resolution of dependencies for a function/class.
      * @param container The container to resolve from.
      * @param key The key that the resolver was registered as.
      * @return Returns the resolved object.
      */
    get(container: Container, key: any): any;
  }
  
  /**
  * A strategy for invoking a function, resulting in an object instance.
  */
  export interface Invoker {
    
    /**
      * Invokes the function with the provided dependencies.
      * @param fn The constructor or factory function.
      * @param dependencies The dependencies of the function call.
      * @return The result of the function invocation.
      */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param fn The constructor or factory function.
      * @param staticDependencies The static dependencies of the function.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
  }
  
  /**
  * Customizes how a particular function is resolved by the Container.
  */
  export interface Registration {
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Used to configure a Container instance.
  */
  export interface ContainerConfiguration {
    
    /**
      * An optional callback which will be called when any function needs an InvocationHandler created (called once per Function).
      */
    onHandlerCreated?: (handler: InvocationHandler) => InvocationHandler;
  }
  
  /**
  * Decorator: Indicates that the decorated class/object is a custom resolver.
  */
  export const resolver: Function;
  
  /**
  * Used to allow functions/classes to specify lazy resolution logic.
  */
  
  /**
  * Used to allow functions/classes to specify lazy resolution logic.
  */
  export class Lazy {
    
    /**
      * Creates an instance of the Lazy class.
      * @param key The key to lazily resolve.
      */
    constructor(key: any);
    
    /**
      * Called by the container to lazily resolve the dependency into a lazy locator function.
      * @param container The container to resolve from.
      * @return Returns a function which can be invoked at a later time to obtain the actual dependency.
      */
    get(container: Container): any;
    
    /**
      * Creates a Lazy Resolver for the supplied key.
      * @param key The key to lazily resolve.
      * @return Returns an instance of Lazy for the key.
      */
    static of(key: any): Lazy;
  }
  
  /**
  * Used to allow functions/classes to specify resolution of all matches to a key.
  */
  export class All {
    
    /**
      * Creates an instance of the All class.
      * @param key The key to lazily resolve all matches for.
      */
    constructor(key: any);
    
    /**
      * Called by the container to resolve all matching dependencies as an array of instances.
      * @param container The container to resolve from.
      * @return Returns an array of all matching instances.
      */
    get(container: Container): any[];
    
    /**
      * Creates an All Resolver for the supplied key.
      * @param key The key to resolve all instances for.
      * @return Returns an instance of All for the key.
      */
    static of(key: any): All;
  }
  
  /**
  * Used to allow functions/classes to specify an optional dependency, which will be resolved only if already registred with the container.
  */
  export class Optional {
    
    /**
      * Creates an instance of the Optional class.
      * @param key The key to optionally resolve for.
      * @param checkParent Indicates whether or not the parent container hierarchy should be checked.
      */
    constructor(key: any, checkParent?: boolean);
    
    /**
      * Called by the container to provide optional resolution of the key.
      * @param container The container to resolve from.
      * @return Returns the instance if found; otherwise null.
      */
    get(container: Container): any;
    
    /**
      * Creates an Optional Resolver for the supplied key.
      * @param key The key to optionally resolve for.
      * @param [checkParent=false] Indicates whether or not the parent container hierarchy should be checked.
      * @return Returns an instance of Optional for the key.
      */
    static of(key: any, checkParent?: boolean): Optional;
  }
  
  /**
  * Used to inject the dependency from the parent container instead of the current one.
  */
  export class Parent {
    
    /**
      * Creates an instance of the Parent class.
      * @param key The key to resolve from the parent container.
      */
    constructor(key: any);
    
    /**
      * Called by the container to load the dependency from the parent container
      * @param container The container to resolve the parent from.
      * @return Returns the matching instance from the parent container
      */
    get(container: Container): any;
    
    /**
      * Creates a Parent Resolver for the supplied key.
      * @param key The key to resolve.
      * @return Returns an instance of Parent for the key.
      */
    static of(key: any): Parent;
  }
  export class StrategyResolver {
    
    /**
      * Creates an instance of the StrategyResolver class.
      * @param strategy The type of resolution strategy.
      * @param state The state associated with the resolution strategy.
      */
    constructor(strategy: any, state: any);
    
    /**
      * Called by the container to allow custom resolution of dependencies for a function/class.
      * @param container The container to resolve from.
      * @param key The key that the resolver was registered as.
      * @return Returns the resolved object.
      */
    get(container: Container, key: any): any;
  }
  
  /**
  * Used to allow injecting dependencies but also passing data to the constructor.
  */
  export class Factory {
    
    /**
      * Creates an instance of the Factory class.
      * @param key The key to resolve from the parent container.
      */
    constructor(key: any);
    
    /**
      * Called by the container to pass the dependencies to the constructor.
      * @param container The container to invoke the constructor with dependencies and other parameters.
      * @return Returns a function that can be invoked to resolve dependencies later, and the rest of the parameters.
      */
    get(container: Container): any;
    
    /**
      * Creates a Factory Resolver for the supplied key.
      * @param key The key to resolve.
      * @return Returns an instance of Factory for the key.
      */
    static of(key: any): Factory;
  }
  
  /**
  * Decorator: Specifies a custom Invoker for the decorated item.
  */
  export function invoker(value: Invoker): any;
  
  /**
  * Decorator: Specifies that the decorated item should be called as a factory function, rather than a constructor.
  */
  export function factory(potentialTarget?: any): any;
  
  /**
  * An Invoker that is used to invoke a factory method.
  */
  /**
  * An Invoker that is used to invoke a factory method.
  */
  export class FactoryInvoker {
    
    /**
      * The singleton instance of the FactoryInvoker.
      */
    static instance: FactoryInvoker;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param container The calling container.
      * @param fn The constructor or factory function.
      * @param dependencies The dependencies of the function call.
      * @return The result of the function invocation.
      */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    
    /**
      * Invokes the function with the provided dependencies.
      * @param container The calling container.
      * @param fn The constructor or factory function.
      * @param staticDependencies The static dependencies of the function.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
  }
  
  /**
  * Decorator: Specifies a custom registration strategy for the decorated class/function.
  */
  export function registration(value: Registration): any;
  
  /**
  * Decorator: Specifies to register the decorated item with a "transient" lifetime.
  */
  export function transient(key?: any): any;
  
  /**
  * Decorator: Specifies to register the decorated item with a "singleton" lieftime.
  */
  export function singleton(keyOrRegisterInChild?: any, registerInChild?: boolean): any;
  
  /**
  * Used to allow functions/classes to indicate that they should be registered as transients with the container.
  */
  /**
  * Used to allow functions/classes to indicate that they should be registered as transients with the container.
  */
  export class TransientRegistration {
    
    /**
      * Creates an instance of TransientRegistration.
      * @param key The key to register as.
      */
    constructor(key?: any);
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Used to allow functions/classes to indicate that they should be registered as singletons with the container.
  */
  export class SingletonRegistration {
    
    /**
      * Creates an instance of SingletonRegistration.
      * @param key The key to register as.
      */
    constructor(keyOrRegisterInChild?: any, registerInChild?: boolean);
    
    /**
      * Called by the container to register the resolver.
      * @param container The container the resolver is being registered with.
      * @param key The key the resolver should be registered as.
      * @param fn The function to create the resolver for.
      * @return The resolver that was registered.
      */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
  }
  
  /**
  * Stores the information needed to invoke a function.
  */
  export class InvocationHandler {
    
    /**
      * The function to be invoked by this handler.
      */
    fn: Function;
    
    /**
      * The invoker implementation that will be used to actually invoke the function.
      */
    invoker: Invoker;
    
    /**
      * The statically known dependencies of this function invocation.
      */
    dependencies: any[];
    
    /**
      * Instantiates an InvocationDescription.
      * @param fn The Function described by this description object.
      * @param invoker The strategy for invoking the function.
      * @param dependencies The static dependencies of the function call.
      */
    constructor(fn: Function, invoker: Invoker, dependencies: any[]);
    
    /**
      * Invokes the function.
      * @param container The calling container.
      * @param dynamicDependencies Additional dependencies to use during invocation.
      * @return The result of the function invocation.
      */
    invoke(container: Container, dynamicDependencies?: any[]): any;
  }
  
  /**
  * A lightweight, extensible dependency injection container.
  */
  export class Container {
    
    /**
      * The global root Container instance. Available if makeGlobal() has been called. Aurelia Framework calls makeGlobal().
      */
    static instance: Container;
    
    /**
      * The parent container in the DI hierarchy.
      */
    parent: Container;
    
    /**
      * The root container in the DI hierarchy.
      */
    root: Container;
    
    /**
      * Creates an instance of Container.
      * @param configuration Provides some configuration for the new Container instance.
      */
    constructor(configuration?: ContainerConfiguration);
    
    /**
      * Makes this container instance globally reachable through Container.instance.
      */
    makeGlobal(): Container;
    
    /**
      * Sets an invocation handler creation callback that will be called when new InvocationsHandlers are created (called once per Function).
      * @param onHandlerCreated The callback to be called when an InvocationsHandler is created.
      */
    setHandlerCreatedCallback(onHandlerCreated: ((handler: InvocationHandler) => InvocationHandler)): any;
    
    /**
      * Registers an existing object instance with the container.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param instance The instance that will be resolved when the key is matched.
      */
    registerInstance(key: any, instance?: any): void;
    
    /**
      * Registers a type (constructor function) such that the container always returns the same instance for each request.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param [fn] The constructor function to use when the dependency needs to be instantiated.
      */
    registerSingleton(key: any, fn?: Function): void;
    
    /**
      * Registers a type (constructor function) such that the container returns a new instance for each request.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param [fn] The constructor function to use when the dependency needs to be instantiated.
      */
    registerTransient(key: any, fn?: Function): void;
    
    /**
      * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param handler The resolution function to use when the dependency is needed.
      */
    registerHandler(key: any, handler: ((container?: Container, key?: any, resolver?: Resolver) => any)): void;
    
    /**
      * Registers an additional key that serves as an alias to the original DI key.
      * @param originalKey The key that originally identified the dependency; usually a constructor function.
      * @param aliasKey An alternate key which can also be used to resolve the same dependency  as the original.
      */
    registerAlias(originalKey: any, aliasKey: any): void;
    
    /**
      * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param resolver The resolver to use when the dependency is needed.
      */
    registerResolver(key: any, resolver: Resolver): void;
    
    /**
      * Registers a type (constructor function) by inspecting its registration annotations. If none are found, then the default singleton registration is used.
      * @param fn The constructor function to use when the dependency needs to be instantiated.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      */
    autoRegister(fn: any, key?: any): Resolver;
    
    /**
      * Registers an array of types (constructor functions) by inspecting their registration annotations. If none are found, then the default singleton registration is used.
      * @param fns The constructor function to use when the dependency needs to be instantiated.
      */
    autoRegisterAll(fns: any[]): void;
    
    /**
      * Unregisters based on key.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      */
    unregister(key: any): void;
    
    /**
      * Inspects the container to determine if a particular key has been registred.
      * @param key The key that identifies the dependency at resolution time; usually a constructor function.
      * @param checkParent Indicates whether or not to check the parent container hierarchy.
      * @return Returns true if the key has been registred; false otherwise.
      */
    hasResolver(key: any, checkParent?: boolean): boolean;
    
    /**
      * Resolves a single instance based on the provided key.
      * @param key The key that identifies the object to resolve.
      * @return Returns the resolved instance.
      */
    get(key: any): any;
    
    /**
      * Resolves all instance registered under the provided key.
      * @param key The key that identifies the objects to resolve.
      * @return Returns an array of the resolved instances.
      */
    getAll(key: any): any[];
    
    /**
      * Creates a new dependency injection container whose parent is the current container.
      * @return Returns a new container instance parented to this.
      */
    createChild(): Container;
    
    /**
      * Invokes a function, recursively resolving its dependencies.
      * @param fn The function to invoke with the auto-resolved dependencies.
      * @param dynamicDependencies Additional function dependencies to use during invocation.
      * @return Returns the instance resulting from calling the function.
      */
    invoke(fn: Function, dynamicDependencies?: any[]): any;
  }
  
  /**
  * Decorator: Directs the TypeScript transpiler to write-out type metadata for the decorated class.
  */
  export function autoinject(potentialTarget?: any): any;
  
  /**
  * Decorator: Specifies the dependencies that should be injected by the DI Container into the decoratored class/function.
  */
  export function inject(...rest: any[]): any;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection/dist/commonjs/aurelia-dependency-injection';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-task-queue/dist/commonjs/aurelia-task-queue.d.ts
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue/dist/commonjs/aurelia-task-queue' {
module 'aurelia-task-queue' {
  import {
    DOM,
    FEATURE
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue~aurelia-pal';
  
  /**
  * Either a Function or a class with a call method that will do work when dequeued.
  */
  export interface Task {
    
    /**
      * Call it.
      */
    call(): void;
  }
  
  /**
  * Implements an asynchronous task queue.
  */
  /**
  * Implements an asynchronous task queue.
  */
  export class TaskQueue {
    
    /**
      * Creates an instance of TaskQueue.
      */
    constructor();
    
    /**
      * Queues a task on the micro task queue for ASAP execution.
      * @param task The task to queue up for ASAP execution.
      */
    queueMicroTask(task: Task | Function): void;
    
    /**
      * Queues a task on the macro task queue for turn-based execution.
      * @param task The task to queue up for turn-based execution.
      */
    queueTask(task: Task | Function): void;
    
    /**
      * Immediately flushes the task queue.
      */
    flushTaskQueue(): void;
    
    /**
      * Immediately flushes the micro task queue.
      */
    flushMicroTaskQueue(): void;
  }
}
}
declare module '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue' {
export * from '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue/dist/commonjs/aurelia-task-queue';
}

// Generated by typings
// Source: node_modules/aurelia-templating/dist/commonjs/aurelia-templating.d.ts
declare module '~aurelia-templating-resources~aurelia-templating/dist/commonjs/aurelia-templating' {
module 'aurelia-templating' {
  import * as LogManager from '~aurelia-templating-resources~aurelia-templating~aurelia-logging';
  import {
    DOM,
    PLATFORM,
    FEATURE
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-pal';
  import {
    Origin,
    protocol,
    metadata
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-metadata';
  import {
    relativeToFile
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-path';
  import {
    TemplateRegistryEntry,
    Loader
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-loader';
  import {
    Binding,
    createOverrideContext,
    ValueConverterResource,
    BindingBehaviorResource,
    subscriberCollection,
    bindingMode,
    ObserverLocator,
    EventManager,
    createScopeForTest
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-binding';
  import {
    Container,
    resolver,
    inject
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-dependency-injection';
  import {
    TaskQueue
  } from '~aurelia-templating-resources~aurelia-templating~aurelia-task-queue';
  export interface CompositionTransactionOwnershipToken {
    waitForCompositionComplete(): Promise<void>;
  }
  export interface CompositionTransactionNotifier {
    done(): void;
  }
  export interface EventHandler {
    eventName: string;
    bubbles: boolean;
    dispose: Function;
    handler: Function;
  }
  
  /**
  * Specifies how a view should be created.
  */
  export interface ViewCreateInstruction {
    
    /**
      * Indicates that the view is being created by enhancing existing DOM.
      */
    enhance?: boolean;
    
    /**
      * Specifies a key/value lookup of part replacements for the view being created.
      */
    partReplacements?: Object;
  }
  
  /**
  * Implemented by classes that describe how a view factory should be loaded.
  */
  export interface ViewStrategy {
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
  }
  
  /**
  * View engine hooks that enable a view resource to provide custom processing during the compilation or creation of a view.
  */
  export interface ViewEngineHooks {
    
    /**
      * Invoked before a template is compiled.
      * @param content The DocumentFragment to compile.
      * @param resources The resources to compile the view against.
      * @param instruction The compilation instruction associated with the compilation process.
      */
    beforeCompile?: (content: DocumentFragment, resources: ViewResources, instruction: ViewCompileInstruction) => void;
    
    /**
      * Invoked after a template is compiled.
      * @param viewFactory The view factory that was produced from the compilation process.
      */
    afterCompile?: (viewFactory: ViewFactory) => void;
    
    /**
      * Invoked before a view is created.
      * @param viewFactory The view factory that will be used to create the view.
      * @param container The DI container used during view creation.
      * @param content The cloned document fragment representing the view.
      * @param instruction The view creation instruction associated with this creation process.
      */
    beforeCreate?: (viewFactory: ViewFactory, container: Container, content: DocumentFragment, instruction: ViewCreateInstruction) => void;
    
    /**
      * Invoked after a view is created.
      * @param view The view that was created by the factory.
      */
    afterCreate?: (view: View) => void;
    
    /**
      * Invoked after the bindingContext and overrideContext are configured on the view but before the view is bound.
      * @param view The view that was created by the factory.
      */
    beforeBind?: (view: View) => void;
    
    /**
      * Invoked before the view is unbind. The bindingContext and overrideContext are still available on the view.
      * @param view The view that was created by the factory.
      */
    beforeUnbind?: (view: View) => void;
  }
  
  /**
  * Represents a node in the view hierarchy.
  */
  export interface ViewNode {
    
    /**
      * Binds the node and it's children.
      * @param bindingContext The binding context to bind to.
      * @param overrideContext A secondary binding context that can override the standard context.
      */
    bind(bindingContext: Object, overrideContext?: Object): void;
    
    /**
      * Triggers the attach for the node and its children.
      */
    attached(): void;
    
    /**
      * Triggers the detach for the node and its children.
      */
    detached(): void;
    
    /**
      * Unbinds the node and its children.
      */
    unbind(): void;
  }
  
  /**
  * Instructs the composition engine how to dynamically compose a component.
  */
  export interface CompositionContext {
    
    /**
      * The parent Container for the component creation.
      */
    container: Container;
    
    /**
      * The child Container for the component creation. One will be created from the parent if not provided.
      */
    childContainer?: Container;
    
    /**
      * The context in which the view model is executed in.
      */
    bindingContext: any;
    
    /**
      * A secondary binding context that can override the standard context.
      */
    overrideContext?: any;
    
    /**
      * The view model url or instance for the component.
      */
    viewModel?: any;
    
    /**
      * Data to be passed to the "activate" hook on the view model.
      */
    model?: any;
    
    /**
      * The HtmlBehaviorResource for the component.
      */
    viewModelResource?: HtmlBehaviorResource;
    
    /**
      * The view resources for the view in which the component should be created.
      */
    viewResources: ViewResources;
    
    /**
      * The view inside which this composition is happening.
      */
    owningView?: View;
    
    /**
      * The view url or view strategy to override the default view location convention.
      */
    view?: string | ViewStrategy;
    
    /**
      * The slot to push the dynamically composed component into.
      */
    viewSlot: ViewSlot;
    
    /**
      * Should the composition system skip calling the "activate" hook on the view model.
      */
    skipActivation?: boolean;
  }
  
  /**
  * Instructs the framework in how to enhance an existing DOM structure.
  */
  export interface EnhanceInstruction {
    
    /**
      * The DI container to use as the root for UI enhancement.
      */
    container?: Container;
    
    /**
      * The element to enhance.
      */
    element: Element;
    
    /**
      * The resources available for enhancement.
      */
    resources?: ViewResources;
    
    /**
      * A binding context for the enhancement.
      */
    bindingContext?: Object;
  }
  
  /**
  * List the events that an Animator should raise.
  */
  export const animationEvent: any;
  
  /**
   * An abstract class representing a mechanism for animating the DOM during various DOM state transitions.
   */
  export class Animator {
    
    /**
       * Execute an 'enter' animation on an element
       * @param element Element to animate
       * @returns Resolved when the animation is done
       */
    enter(element: HTMLElement): Promise<boolean>;
    
    /**
       * Execute a 'leave' animation on an element
       * @param element Element to animate
       * @returns Resolved when the animation is done
       */
    leave(element: HTMLElement): Promise<boolean>;
    
    /**
       * Add a class to an element to trigger an animation.
       * @param element Element to animate
       * @param className Properties to animate or name of the effect to use
       * @returns Resolved when the animation is done
       */
    removeClass(element: HTMLElement, className: string): Promise<boolean>;
    
    /**
       * Add a class to an element to trigger an animation.
       * @param element Element to animate
       * @param className Properties to animate or name of the effect to use
       * @returns Resolved when the animation is done
       */
    addClass(element: HTMLElement, className: string): Promise<boolean>;
    
    /**
       * Execute a single animation.
       * @param element Element to animate
       * @param className Properties to animate or name of the effect to use. For css animators this represents the className to be added and removed right after the animation is done.
       * @param options options for the animation (duration, easing, ...)
       * @returns Resolved when the animation is done
       */
    animate(element: HTMLElement | Array<HTMLElement>, className: string): Promise<boolean>;
    
    /**
       * Run a sequence of animations one after the other.
       * for example: animator.runSequence("fadeIn","callout")
       * @param sequence An array of effectNames or classNames
       * @returns Resolved when all animations are done
       */
    runSequence(animations: Array<any>): Promise<boolean>;
    
    /**
       * Register an effect (for JS based animators)
       * @param effectName identifier of the effect
       * @param properties Object with properties for the effect
       */
    registerEffect(effectName: string, properties: Object): void;
    
    /**
       * Unregister an effect (for JS based animators)
       * @param effectName identifier of the effect
       */
    unregisterEffect(effectName: string): void;
  }
  
  /**
  * Enables an initiator of a view composition to track any internal async rendering processes for completion.
  */
  /**
  * Enables an initiator of a view composition to track any internal async rendering processes for completion.
  */
  export class CompositionTransaction {
    
    /**
      * Creates an instance of CompositionTransaction.
      */
    constructor();
    
    /**
      * Attempt to take ownership of the composition transaction.
      * @return An ownership token if successful, otherwise null.
      */
    tryCapture(): CompositionTransactionOwnershipToken;
    
    /**
      * Enlist an async render operation into the transaction.
      * @return A completion notifier.
      */
    enlist(): CompositionTransactionNotifier;
  }
  
  /**
   * Dispatches subscribets to and publishes events in the DOM.
   * @param element
   */
  /**
   * Dispatches subscribets to and publishes events in the DOM.
   * @param element
   */
  export class ElementEvents {
    constructor(element: Element);
    
    /**
       * Dispatches an Event on the context element.
       * @param eventName
       * @param detail
       * @param bubbles
       * @param cancelable
       */
    publish(eventName: string, detail?: Object, bubbles?: boolean, cancelable?: boolean): any;
    
    /**
       * Adds and Event Listener on the context element.
       * @param eventName
       * @param handler
       * @param bubbles
       * @return Returns the eventHandler containing a dispose method
       */
    subscribe(eventName: string, handler: Function, bubbles?: boolean): EventHandler;
    
    /**
       * Adds an Event Listener on the context element, that will be disposed on the first trigger.
       * @param eventName
       * @param handler
       * @param bubbles
       * @return Returns the eventHandler containing a dispose method
       */
    subscribeOnce(eventName: String, handler: Function, bubbles?: Boolean): EventHandler;
    
    /**
       * Removes all events that are listening to the specified eventName.
       * @param eventName
       */
    dispose(eventName: string): void;
    
    /**
       * Removes all event handlers.
       */
    disposeAll(): any;
  }
  
  /**
  * A context that flows through the view resource load process.
  */
  export class ResourceLoadContext {
    
    /**
      * Creates an instance of ResourceLoadContext.
      */
    constructor();
    
    /**
      * Tracks a dependency that is being loaded.
      * @param url The url of the dependency.
      */
    addDependency(url: string): void;
    
    /**
      * Checks if the current context includes a load of the specified url.
      * @return True if the url is being loaded in the context; false otherwise.
      */
    hasDependency(url: string): boolean;
  }
  
  /**
  * Specifies how a view should be compiled.
  */
  export class ViewCompileInstruction {
    
    /**
      * The normal configuration for view compilation.
      */
    static normal: ViewCompileInstruction;
    
    /**
      * Creates an instance of ViewCompileInstruction.
      * @param targetShadowDOM Should the compilation target the Shadow DOM.
      * @param compileSurrogate Should the compilation also include surrogate bindings and behaviors.
      */
    constructor(targetShadowDOM?: boolean, compileSurrogate?: boolean);
  }
  
  /**
  * Indicates how a custom attribute or element should be instantiated in a view.
  */
  /**
  * Indicates how a custom attribute or element should be instantiated in a view.
  */
  export class BehaviorInstruction {
    
    /**
      * A default behavior used in scenarios where explicit configuration isn't available.
      */
    static normal: BehaviorInstruction;
    
    /**
      * Creates an instruction for element enhancement.
      * @return The created instruction.
      */
    static enhance(): BehaviorInstruction;
    
    /**
      * Creates an instruction for unit testing.
      * @param type The HtmlBehaviorResource to create.
      * @param attributes A key/value lookup of attributes for the behaior.
      * @return The created instruction.
      */
    static unitTest(type: HtmlBehaviorResource, attributes: Object): BehaviorInstruction;
    
    /**
      * Creates a custom element instruction.
      * @param node The node that represents the custom element.
      * @param type The HtmlBehaviorResource to create.
      * @return The created instruction.
      */
    static element(node: Node, type: HtmlBehaviorResource): BehaviorInstruction;
    
    /**
      * Creates a custom attribute instruction.
      * @param attrName The name of the attribute.
      * @param type The HtmlBehaviorResource to create.
      * @return The created instruction.
      */
    static attribute(attrName: string, type?: HtmlBehaviorResource): BehaviorInstruction;
    
    /**
      * Creates a dynamic component instruction.
      * @param host The element that will parent the dynamic component.
      * @param viewModel The dynamic component's view model instance.
      * @param viewFactory A view factory used in generating the component's view.
      * @return The created instruction.
      */
    static dynamic(host: Element, viewModel: Object, viewFactory: ViewFactory): BehaviorInstruction;
    
    /**
      * Creates an instance of BehaviorInstruction.
      */
    constructor();
  }
  
  /**
  * Provides all the instructions for how a target element should be enhanced inside of a view.
  */
  export class TargetInstruction {
    
    /**
      * An empty array used to represent a target with no binding expressions.
      */
    static noExpressions: any;
    
    /**
      * Creates an instruction that represents a content selector.
      * @param node The node that represents the selector.
      * @param parentInjectorId The id of the parent dependency injection container.
      * @return The created instruction.
      */
    static contentSelector(node: Node, parentInjectorId: number): TargetInstruction;
    
    /**
      * Creates an instruction that represents a binding expression in the content of an element.
      * @param expression The binding expression.
      * @return The created instruction.
      */
    static contentExpression(expression: any): TargetInstruction;
    
    /**
      * Creates an instruction that represents content that was lifted out of the DOM and into a ViewFactory.
      * @param parentInjectorId The id of the parent dependency injection container.
      * @param liftingInstruction The behavior instruction of the lifting behavior.
      * @return The created instruction.
      */
    static lifting(parentInjectorId: number, liftingInstruction: BehaviorInstruction): TargetInstruction;
    
    /**
      * Creates an instruction that represents an element with behaviors and bindings.
      * @param injectorId The id of the dependency injection container.
      * @param parentInjectorId The id of the parent dependency injection container.
      * @param providers The types which will provide behavior for this element.
      * @param behaviorInstructions The instructions for creating behaviors on this element.
      * @param expressions Bindings, listeners, triggers, etc.
      * @param elementInstruction The element behavior for this element.
      * @return The created instruction.
      */
    static normal(injectorId: number, parentInjectorId: number, providers: Array<Function>, behaviorInstructions: Array<BehaviorInstruction>, expressions: Array<Object>, elementInstruction: BehaviorInstruction): TargetInstruction;
    
    /**
      * Creates an instruction that represents the surrogate behaviors and bindings for an element.
      * @param providers The types which will provide behavior for this element.
      * @param behaviorInstructions The instructions for creating behaviors on this element.
      * @param expressions Bindings, listeners, triggers, etc.
      * @param values A key/value lookup of attributes to transplant.
      * @return The created instruction.
      */
    static surrogate(providers: Array<Function>, behaviorInstructions: Array<BehaviorInstruction>, expressions: Array<Object>, values: Object): TargetInstruction;
    
    /**
      * Creates an instance of TargetInstruction.
      */
    constructor();
  }
  
  /**
  * Decorator: Indicates that the decorated class/object is a view strategy.
  */
  /**
  * Decorator: Indicates that the decorated class/object is a view strategy.
  */
  export const viewStrategy: Function;
  
  /**
  * A view strategy that loads a view relative to its associated view-model.
  */
  export class RelativeViewStrategy {
    
    /**
      * Creates an instance of RelativeViewStrategy.
      * @param path The relative path to the view.
      */
    constructor(path: string);
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
    
    /**
      * Makes the view loaded by this strategy relative to the provided file path.
      * @param file The path to load the view relative to.
      */
    makeRelativeTo(file: string): void;
  }
  
  /**
  * A view strategy based on naming conventions.
  */
  export class ConventionalViewStrategy {
    
    /**
      * Creates an instance of ConventionalViewStrategy.
      * @param viewLocator The view locator service for conventionally locating the view.
      * @param origin The origin of the view model to conventionally load the view for.
      */
    constructor(viewLocator: ViewLocator, origin: Origin);
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
  }
  
  /**
  * A view strategy that indicates that the component has no view that the templating engine needs to manage.
  * Typically used when the component author wishes to take over fine-grained rendering control.
  */
  export class NoViewStrategy {
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
  }
  
  /**
  * A view strategy created directly from the template registry entry.
  */
  export class TemplateRegistryViewStrategy {
    
    /**
      * Creates an instance of TemplateRegistryViewStrategy.
      * @param moduleId The associated moduleId of the view to be loaded.
      * @param entry The template registry entry used in loading the view factory.
      */
    constructor(moduleId: string, entry: TemplateRegistryEntry);
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
  }
  
  /**
  * A view strategy that allows the component authore to inline the html for the view.
  */
  export class InlineViewStrategy {
    
    /**
      * Creates an instance of InlineViewStrategy.
      * @param markup The markup for the view. Be sure to include the wrapping template tag.
      * @param dependencies A list of view resource dependencies of this view.
      * @param dependencyBaseUrl The base url for the view dependencies.
      */
    constructor(markup: string, dependencies?: Array<string | Function | Object>, dependencyBaseUrl?: string);
    
    /**
      * Loads a view factory.
      * @param viewEngine The view engine to use during the load process.
      * @param compileInstruction Additional instructions to use during compilation of the view.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise for the view factory that is produced by this strategy.
      */
    loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
  }
  
  /**
  * Locates a view for an object.
  */
  export class ViewLocator {
    
    /**
      * The metadata key for storing/finding view strategies associated with an class/object.
      */
    static viewStrategyMetadataKey: any;
    
    /**
      * Gets the view strategy for the value.
      * @param value The value to locate the view strategy for.
      * @return The located ViewStrategy instance.
      */
    getViewStrategy(value: any): ViewStrategy;
    
    /**
      * Creates a fallback View Strategy. Used when unable to locate a configured strategy.
      * The default implementation returns and instance of ConventionalViewStrategy.
      * @param origin The origin of the view model to return the strategy for.
      * @return The fallback ViewStrategy.
      */
    createFallbackViewStrategy(origin: Origin): ViewStrategy;
    
    /**
      * Conventionally converts a view model origin to a view url.
      * Used by the ConventionalViewStrategy.
      * @param origin The origin of the view model to convert.
      * @return The view url.
      */
    convertOriginToViewUrl(origin: Origin): string;
  }
  
  /**
  * An abstract base class for implementations of a binding language.
  */
  export class BindingLanguage {
    
    /**
      * Inspects an attribute for bindings.
      * @param resources The ViewResources for the view being compiled.
      * @param attrName The attribute name to inspect.
      * @param attrValue The attribute value to inspce.
      * @return An info object with the results of the inspection.
      */
    inspectAttribute(resources: ViewResources, attrName: string, attrValue: string): Object;
    
    /**
      * Creates an attribute behavior instruction.
      * @param resources The ViewResources for the view being compiled.
      * @param element The element that the attribute is defined on.
      * @param info The info object previously returned from inspectAttribute.
      * @param existingInstruction A previously created instruction for this attribute.
      * @return The instruction instance.
      */
    createAttributeInstruction(resources: ViewResources, element: Element, info: Object, existingInstruction?: Object): BehaviorInstruction;
    
    /**
      * Parses the text for bindings.
      * @param resources The ViewResources for the view being compiled.
      * @param value The value of the text to parse.
      * @return A binding expression.
      */
    parseText(resources: ViewResources, value: string): Object;
  }
  
  /**
  * Represents a collection of resources used during the compilation of a view.
  */
  /**
  * Represents a collection of resources used during the compilation of a view.
  */
  export class ViewResources {
    
    /**
      * A custom binding language used in the view.
      */
    bindingLanguage: any;
    
    /**
      * Creates an instance of ViewResources.
      * @param parent The parent resources. This resources can override them, but if a resource is not found, it will be looked up in the parent.
      * @param viewUrl The url of the view to which these resources apply.
      */
    constructor(parent?: ViewResources, viewUrl?: string);
    
    /**
      * Registers view engine hooks for the view.
      * @param hooks The hooks to register.
      */
    registerViewEngineHooks(hooks: ViewEngineHooks): void;
    
    /**
      * Gets the binding language associated with these resources, or return the provided fallback implementation.
      * @param bindingLanguageFallback The fallback binding language implementation to use if no binding language is configured locally.
      * @return The binding language.
      */
    getBindingLanguage(bindingLanguageFallback: BindingLanguage): BindingLanguage;
    
    /**
      * Patches an immediate parent into the view resource resolution hierarchy.
      * @param newParent The new parent resources to patch in.
      */
    patchInParent(newParent: ViewResources): void;
    
    /**
      * Maps a path relative to the associated view's origin.
      * @param path The relative path.
      * @return The calcualted path.
      */
    relativeToView(path: string): string;
    
    /**
      * Registers an HTML element.
      * @param tagName The name of the custom element.
      * @param behavior The behavior of the element.
      */
    registerElement(tagName: string, behavior: HtmlBehaviorResource): void;
    
    /**
      * Gets an HTML element behavior.
      * @param tagName The tag name to search for.
      * @return The HtmlBehaviorResource for the tag name or null.
      */
    getElement(tagName: string): HtmlBehaviorResource;
    
    /**
      * Gets the known attribute name based on the local attribute name.
      * @param attribute The local attribute name to lookup.
      * @return The known name.
      */
    mapAttribute(attribute: string): string;
    
    /**
      * Registers an HTML attribute.
      * @param attribute The name of the attribute.
      * @param behavior The behavior of the attribute.
      * @param knownAttribute The well-known name of the attribute (in lieu of the local name).
      */
    registerAttribute(attribute: string, behavior: HtmlBehaviorResource, knownAttribute: string): void;
    
    /**
      * Gets an HTML attribute behavior.
      * @param attribute The name of the attribute to lookup.
      * @return The HtmlBehaviorResource for the attribute or null.
      */
    getAttribute(attribute: string): HtmlBehaviorResource;
    
    /**
      * Registers a value converter.
      * @param name The name of the value converter.
      * @param valueConverter The value converter instance.
      */
    registerValueConverter(name: string, valueConverter: Object): void;
    
    /**
      * Gets a value converter.
      * @param name The name of the value converter.
      * @return The value converter instance.
      */
    getValueConverter(name: string): Object;
    
    /**
      * Registers a binding behavior.
      * @param name The name of the binding behavior.
      * @param bindingBehavior The binding behavior instance.
      */
    registerBindingBehavior(name: string, bindingBehavior: Object): void;
    
    /**
      * Gets a binding behavior.
      * @param name The name of the binding behavior.
      * @return The binding behavior instance.
      */
    getBindingBehavior(name: string): Object;
  }
  export class View {
    
    /**
      * Creates a View instance.
      * @param viewFactory The factory that created this view.
      * @param fragment The DOM fragement representing the view.
      * @param controllers The controllers inside this view.
      * @param bindings The bindings inside this view.
      * @param children The children of this view.
      */
    constructor(viewFactory: ViewFactory, fragment: DocumentFragment, controllers: Controller[], bindings: Binding[], children: ViewNode[], contentSelectors: Array<Object>);
    
    /**
      * Returns this view to the appropriate view cache.
      */
    returnToCache(): void;
    
    /**
      * Triggers the created callback for this view and its children.
      */
    created(): void;
    
    /**
      * Binds the view and it's children.
      * @param bindingContext The binding context to bind to.
      * @param overrideContext A secondary binding context that can override the standard context.
      */
    bind(bindingContext: Object, overrideContext?: Object, _systemUpdate?: boolean): void;
    
    /**
      * Adds a binding instance to this view.
      * @param binding The binding instance.
      */
    addBinding(binding: Object): void;
    
    /**
      * Unbinds the view and its children.
      */
    unbind(): void;
    
    /**
      * Inserts this view's nodes before the specified DOM node.
      * @param refNode The node to insert this view's nodes before.
      */
    insertNodesBefore(refNode: Node): void;
    
    /**
      * Appends this view's to the specified DOM node.
      * @param parent The parent element to append this view's nodes to.
      */
    appendNodesTo(parent: Element): void;
    
    /**
      * Removes this view's nodes from the DOM.
      */
    removeNodes(): void;
    
    /**
      * Triggers the attach for the view and its children.
      */
    attached(): void;
    
    /**
      * Triggers the detach for the view and its children.
      */
    detached(): void;
  }
  
  /**
  * Represents a slot or location within the DOM to which views can be added and removed.
  * Manages the view lifecycle for its children.
  */
  export class ViewSlot {
    
    /**
      * Creates an instance of ViewSlot.
      * @param anchor The DOM node which will server as the anchor or container for insertion.
      * @param anchorIsContainer Indicates whether the node is a container.
      * @param animator The animator that will controll enter/leave transitions for this slot.
      */
    constructor(anchor: Node, anchorIsContainer: boolean, animator?: Animator);
    
    /**
      * Takes the child nodes of an existing element that has been converted into a ViewSlot
      * and makes those nodes into a View within the slot.
      */
    transformChildNodesIntoView(): void;
    
    /**
      * Binds the slot and it's children.
      * @param bindingContext The binding context to bind to.
      * @param overrideContext A secondary binding context that can override the standard context.
      */
    bind(bindingContext: Object, overrideContext: Object): void;
    
    /**
      * Unbinds the slot and its children.
      */
    unbind(): void;
    
    /**
      * Adds a view to the slot.
      * @param view The view to add.
      * @return May return a promise if the view addition triggered an animation.
      */
    add(view: View): void | Promise<any>;
    
    /**
      * Inserts a view into the slot.
      * @param index The index to insert the view at.
      * @param view The view to insert.
      * @return May return a promise if the view insertion triggered an animation.
      */
    insert(index: number, view: View): void | Promise<any>;
    
    /**
      * Removes a view from the slot.
      * @param view The view to remove.
      * @param returnToCache Should the view be returned to the view cache?
      * @param skipAnimation Should the removal animation be skipped?
      * @return May return a promise if the view removal triggered an animation.
      */
    remove(view: View, returnToCache?: boolean, skipAnimation?: boolean): void | Promise<View>;
    
    /**
      * Removes a view an a specified index from the slot.
      * @param index The index to remove the view at.
      * @param returnToCache Should the view be returned to the view cache?
      * @param skipAnimation Should the removal animation be skipped?
      * @return May return a promise if the view removal triggered an animation.
      */
    removeAt(index: number, returnToCache?: boolean, skipAnimation?: boolean): void | Promise<View>;
    
    /**
      * Removes all views from the slot.
      * @param returnToCache Should the view be returned to the view cache?
      * @param skipAnimation Should the removal animation be skipped?
      * @return May return a promise if the view removals triggered an animation.
      */
    removeAll(returnToCache?: boolean, skipAnimation?: boolean): void | Promise<any>;
    
    /**
      * Triggers the attach for the slot and its children.
      */
    attached(): void;
    
    /**
      * Triggers the detach for the slot and its children.
      */
    detached(): void;
  }
  
  /**
  * A factory capable of creating View instances, bound to a location within another view hierarchy.
  */
  export class BoundViewFactory {
    
    /**
      * Creates an instance of BoundViewFactory.
      * @param parentContainer The parent DI container.
      * @param viewFactory The internal unbound factory.
      * @param partReplacements Part replacement overrides for the internal factory.
      */
    constructor(parentContainer: Container, viewFactory: ViewFactory, partReplacements?: Object);
    
    //This is referenced internally in the controller's bind method.
    /**
      * Creates a view or returns one from the internal cache, if available.
      * @return The created view.
      */
    create(): View;
    
    /**
      * Indicates whether this factory is currently using caching.
      */
    isCaching: any;
    
    /**
      * Sets the cache size for this factory.
      * @param size The number of views to cache or "*" to cache all.
      * @param doNotOverrideIfAlreadySet Indicates that setting the cache should not override the setting if previously set.
      */
    setCacheSize(size: number | string, doNotOverrideIfAlreadySet: boolean): void;
    
    /**
      * Gets a cached view if available...
      * @return A cached view or null if one isn't available.
      */
    getCachedView(): View;
    
    /**
      * Returns a view to the cache.
      * @param view The view to return to the cache if space is available.
      */
    returnViewToCache(view: View): void;
  }
  
  /**
  * A factory capable of creating View instances.
  */
  export class ViewFactory {
    
    /**
      * Indicates whether this factory is currently using caching.
      */
    isCaching: any;
    
    /**
      * Creates an instance of ViewFactory.
      * @param template The document fragment that serves as a template for the view to be created.
      * @param instructions The instructions to be applied ot the template during the creation of a view.
      * @param resources The resources used to compile this factory.
      */
    constructor(template: DocumentFragment, instructions: Object, resources: ViewResources);
    
    /**
      * Sets the cache size for this factory.
      * @param size The number of views to cache or "*" to cache all.
      * @param doNotOverrideIfAlreadySet Indicates that setting the cache should not override the setting if previously set.
      */
    setCacheSize(size: number | string, doNotOverrideIfAlreadySet: boolean): void;
    
    /**
      * Gets a cached view if available...
      * @return A cached view or null if one isn't available.
      */
    getCachedView(): View;
    
    /**
      * Returns a view to the cache.
      * @param view The view to return to the cache if space is available.
      */
    returnViewToCache(view: View): void;
    
    /**
      * Creates a view or returns one from the internal cache, if available.
      * @param container The container to create the view from.
      * @param createInstruction The instruction used to customize view creation.
      * @param element The custom element that hosts the view.
      * @return The created view.
      */
    create(container: Container, createInstruction?: ViewCreateInstruction, element?: Element): View;
  }
  
  /**
  * Compiles html templates, dom fragments and strings into ViewFactory instances, capable of instantiating Views.
  */
  export class ViewCompiler {
    
    /**
      * Creates an instance of ViewCompiler.
      * @param bindingLanguage The default data binding language and syntax used during view compilation.
      * @param resources The global resources used during compilation when none are provided for compilation.
      */
    constructor(bindingLanguage: BindingLanguage, resources: ViewResources);
    
    /**
      * Compiles an html template, dom fragment or string into ViewFactory instances, capable of instantiating Views.
      * @param source The template, fragment or string to compile.
      * @param resources The view resources used during compilation.
      * @param compileInstruction A set of instructions that customize how compilation occurs.
      * @return The compiled ViewFactory.
      */
    compile(source: Element | DocumentFragment | string, resources?: ViewResources, compileInstruction?: ViewCompileInstruction): ViewFactory;
  }
  
  /**
  * Represents a module with view resources.
  */
  export class ResourceModule {
    
    /**
      * Creates an instance of ResourceModule.
      * @param moduleId The id of the module that contains view resources.
      */
    constructor(moduleId: string);
    
    /**
      * Initializes the resources within the module.
      * @param container The dependency injection container usable during resource initialization.
      */
    initialize(container: Container): void;
    
    /**
      * Registers the resources in the module with the view resources.
      * @param registry The registry of view resources to regiser within.
      * @param name The name to use in registering the default resource.
      */
    register(registry: ViewResources, name?: string): void;
    
    /**
      * Loads any dependencies of the resources within this module.
      * @param container The DI container to use during dependency resolution.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise that resolves when all loading is complete.
      */
    load(container: Container, loadContext?: ResourceLoadContext): Promise<void>;
  }
  
  /**
  * Represents a single view resource with a ResourceModule.
  */
  export class ResourceDescription {
    
    /**
      * Creates an instance of ResourceDescription.
      * @param key The key that the resource was exported as.
      * @param exportedValue The exported resource.
      * @param resourceTypeMeta The metadata located on the resource.
      */
    constructor(key: string, exportedValue: any, resourceTypeMeta?: Object);
    
    /**
      * Initializes the resource.
      * @param container The dependency injection container usable during resource initialization.
      */
    initialize(container: Container): void;
    
    /**
      * Registrers the resource with the view resources.
      * @param registry The registry of view resources to regiser within.
      * @param name The name to use in registering the resource.
      */
    register(registry: ViewResources, name?: string): void;
    
    /**
      * Loads any dependencies of the resource.
      * @param container The DI container to use during dependency resolution.
      * @param loadContext The loading context used for loading all resources and dependencies.
      * @return A promise that resolves when all loading is complete.
      */
    load(container: Container, loadContext?: ResourceLoadContext): Promise<void> | void;
  }
  
  /**
  * Analyzes a module in order to discover the view resources that it exports.
  */
  export class ModuleAnalyzer {
    
    /**
      * Creates an instance of ModuleAnalyzer.
      */
    constructor();
    
    /**
      * Retrieves the ResourceModule analysis for a previously analyzed module.
      * @param moduleId The id of the module to lookup.
      * @return The ResouceModule if found, undefined otherwise.
      */
    getAnalysis(moduleId: string): ResourceModule;
    
    /**
      * Analyzes a module.
      * @param moduleId The id of the module to analyze.
      * @param moduleInstance The module instance to analyze.
      * @param mainResourceKey The name of the main resource.
      * @return The ResouceModule representing the analysis.
      */
    analyze(moduleId: string, moduleInstance: any, mainResourceKey?: string): ResourceModule;
  }
  
  /**
  * Controls the view resource loading pipeline.
  */
  export class ViewEngine {
    
    /**
      * Creates an instance of ViewEngine.
      * @param loader The module loader.
      * @param container The root DI container for the app.
      * @param viewCompiler The view compiler.
      * @param moduleAnalyzer The module analyzer.
      * @param appResources The app-level global resources.
      */
    constructor(loader: Loader, container: Container, viewCompiler: ViewCompiler, moduleAnalyzer: ModuleAnalyzer, appResources: ViewResources);
    
    /**
      * Adds a resource plugin to the resource loading pipeline.
      * @param extension The file extension to match in require elements.
      * @param implementation The plugin implementation that handles the resource type.
      */
    addResourcePlugin(extension: string, implementation: Object): void;
    
    /**
      * Loads and compiles a ViewFactory from a url or template registry entry.
      * @param urlOrRegistryEntry A url or template registry entry to generate the view factory for.
      * @param compileInstruction Instructions detailing how the factory should be compiled.
      * @param loadContext The load context if this factory load is happening within the context of a larger load operation.
      * @return A promise for the compiled view factory.
      */
    loadViewFactory(urlOrRegistryEntry: string | TemplateRegistryEntry, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>;
    
    /**
      * Loads all the resources specified by the registry entry.
      * @param registryEntry The template registry entry to load the resources for.
      * @param compileInstruction The compile instruction associated with the load.
      * @param loadContext The load context if this is happening within the context of a larger load operation.
      * @return A promise of ViewResources for the registry entry.
      */
    loadTemplateResources(registryEntry: TemplateRegistryEntry, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewResources>;
    
    /**
      * Loads a view model as a resource.
      * @param moduleImport The module to import.
      * @param moduleMember The export from the module to generate the resource for.
      * @return A promise for the ResourceDescription.
      */
    importViewModelResource(moduleImport: string, moduleMember: string): Promise<ResourceDescription>;
    
    /**
      * Imports the specified resources with the specified names into the view resources object.
      * @param moduleIds The modules to load.
      * @param names The names associated with resource modules to import.
      * @param resources The resources lookup to add the loaded resources to.
      * @param compileInstruction The compilation instruction associated with the resource imports.
      * @return A promise for the ViewResources.
      */
    importViewResources(moduleIds: string[], names: string[], resources: ViewResources, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewResources>;
  }
  
  /**
  * Controls a view model (and optionally its view), according to a particular behavior and by following a set of instructions.
  */
  export class Controller {
    
    /**
      * The HtmlBehaviorResource that provides the base behavior for this controller.
      */
    behavior: HtmlBehaviorResource;
    
    /**
      * The developer's view model instance which provides the custom behavior for this controller.
      */
    viewModel: Object;
    
    /**
      * The view associated with the component being controlled by this controller.
      * Note: Not all components will have a view, so the value may be null.
      */
    view: View;
    
    /**
      * Creates an instance of Controller.
      * @param behavior The HtmlBehaviorResource that provides the base behavior for this controller.
      * @param instruction The instructions pertaining to the controller's behavior.
      * @param viewModel The developer's view model instance which provides the custom behavior for this controller.
      */
    constructor(behavior: HtmlBehaviorResource, instruction: BehaviorInstruction, viewModel: Object, elementEvents?: ElementEvents);
    
    /**
      * Invoked when the view which contains this controller is created.
      * @param owningView The view inside which this controller resides.
      */
    created(owningView: View): void;
    
    /**
      * Used to automate the proper binding of this controller and its view. Used by the composition engine for dynamic component creation.
      * This should be considered a semi-private API and is subject to change without notice, even across minor or patch releases.
      * @param overrideContext An override context for binding.
      * @param owningView The view inside which this controller resides.
      */
    automate(overrideContext?: Object, owningView?: View): void;
    
    /**
      * Binds the controller to the scope.
      * @param scope The binding scope.
      */
    bind(scope: Object): void;
    
    /**
      * Unbinds the controller.
      */
    unbind(): void;
    
    /**
      * Attaches the controller.
      */
    attached(): void;
    
    /**
      * Detaches the controller.
      */
    detached(): void;
  }
  
  /**
  * An implementation of Aurelia's Observer interface that is used to back bindable properties defined on a behavior.
  */
  export class BehaviorPropertyObserver {
    
    /**
      * Creates an instance of BehaviorPropertyObserver.
      * @param taskQueue The task queue used to schedule change notifications.
      * @param obj The object that the property is defined on.
      * @param propertyName The name of the property.
      * @param selfSubscriber The callback function that notifies the object which defines the properties, if present.
      * @param initialValue The initial value of the property.
      */
    constructor(taskQueue: TaskQueue, obj: Object, propertyName: string, selfSubscriber: Function, initialValue: any);
    
    /**
      * Gets the property's value.
      */
    getValue(): any;
    
    /**
      * Sets the property's value.
      * @param newValue The new value to set.
      */
    setValue(newValue: any): void;
    
    /**
      * Invoked by the TaskQueue to publish changes to subscribers.
      */
    call(): void;
    
    /**
      * Subscribes to the observerable.
      * @param context A context object to pass along to the subscriber when it's called.
      * @param callable A function or object with a "call" method to be invoked for delivery of changes.
      */
    subscribe(context: any, callable: Function): void;
    
    /**
      * Unsubscribes from the observerable.
      * @param context The context object originally subscribed with.
      * @param callable The callable that was originally subscribed with.
      */
    unsubscribe(context: any, callable: Function): void;
  }
  
  /**
  * Represents a bindable property on a behavior.
  */
  export class BindableProperty {
    
    /**
      * Creates an instance of BindableProperty.
      * @param nameOrConfig The name of the property or a cofiguration object.
      */
    constructor(nameOrConfig: string | Object);
    
    /**
      * Registers this bindable property with particular Class and Behavior instance.
      * @param target The class to register this behavior with.
      * @param behavior The behavior instance to register this property with.
      * @param descriptor The property descriptor for this property.
      */
    registerWith(target: Function, behavior: HtmlBehaviorResource, descriptor?: Object): void;
    
    /**
      * Defines this property on the specified class and behavior.
      * @param target The class to define the property on.
      * @param behavior The behavior to define the property on.
      */
    defineOn(target: Function, behavior: HtmlBehaviorResource): void;
    
    /**
      * Creates an observer for this property.
      * @param viewModel The view model instance on which to create the observer.
      * @return The property observer.
      */
    createObserver(viewModel: Object): BehaviorPropertyObserver;
  }
  
  /**
  * Identifies a class as a resource that implements custom element or custom
  * attribute functionality.
  */
  export class HtmlBehaviorResource {
    
    /**
      * Creates an instance of HtmlBehaviorResource.
      */
    constructor();
    
    /**
      * Checks whether the provided name matches any naming conventions for HtmlBehaviorResource.
      * @param name The name of the potential resource.
      * @param existing An already existing resource that may need a convention name applied.
      */
    static convention(name: string, existing?: HtmlBehaviorResource): HtmlBehaviorResource;
    
    /**
      * Adds a binding expression to the component created by this resource.
      * @param behavior The binding expression.
      */
    addChildBinding(behavior: Object): void;
    
    /**
      * Provides an opportunity for the resource to initialize iteself.
      * @param container The dependency injection container from which the resource
      * can aquire needed services.
      * @param target The class to which this resource metadata is attached.
      */
    initialize(container: Container, target: Function): void;
    
    /**
      * Allows the resource to be registered in the view resources for the particular
      * view into which it was required.
      * @param registry The view resource registry for the view that required this resource.
      * @param name The name provided by the end user for this resource, within the
      * particular view it's being used.
      */
    register(registry: ViewResources, name?: string): void;
    
    /**
      * Enables the resource to asynchronously load additional resources.
      * @param container The dependency injection container from which the resource
      * can aquire needed services.
      * @param target The class to which this resource metadata is attached.
      * @param loadContext The loading context object provided by the view engine.
      * @param viewStrategy A view strategy to overload the default strategy defined by the resource.
      * @param transientView Indicated whether the view strategy is transient or
      * permanently tied to this component.
      */
    load(container: Container, target: Function, loadContext?: ResourceLoadContext, viewStrategy?: ViewStrategy, transientView?: boolean): Promise<HtmlBehaviorResource>;
    
    /**
      * Plugs into the compiler and enables custom processing of the node on which this behavior is located.
      * @param compiler The compiler that is currently compiling the view that this behavior exists within.
      * @param resources The resources for the view that this behavior exists within.
      * @param node The node on which this behavior exists.
      * @param instruction The behavior instruction created for this behavior.
      * @param parentNode The parent node of the current node.
      * @return The current node.
      */
    compile(compiler: ViewCompiler, resources: ViewResources, node: Node, instruction: BehaviorInstruction, parentNode?: Node): Node;
    
    /**
      * Creates an instance of this behavior.
      * @param container The DI container to create the instance in.
      * @param instruction The instruction for this behavior that was constructed during compilation.
      * @param element The element on which this behavior exists.
      * @param bindings The bindings that are associated with the view in which this behavior exists.
      * @return The Controller of this behavior.
      */
    create(container: Container, instruction?: BehaviorInstruction, element?: Element, bindings?: Binding[]): Controller;
  }
  
  /**
  * Creates a behavior property that references an array of immediate content child elements that matches the provided selector.
  */
  export function children(selectorOrConfig: string | Object): any;
  
  /**
  * Creates a behavior property that references an immediate content child element that matches the provided selector.
  */
  export function child(selectorOrConfig: string | Object): any;
  
  /**
  * Used to dynamically compose components.
  */
  export class CompositionEngine {
    
    /**
      * Creates an instance of the CompositionEngine.
      * @param viewEngine The ViewEngine used during composition.
      */
    constructor(viewEngine: ViewEngine, viewLocator: ViewLocator);
    
    /**
      * Creates a controller instance for the component described in the context.
      * @param context The CompositionContext that describes the component.
      * @return A Promise for the Controller.
      */
    createController(context: CompositionContext): Promise<Controller>;
    
    /**
      * Ensures that the view model and its resource are loaded for this context.
      * @param context The CompositionContext to load the view model and its resource for.
      * @return A Promise for the context.
      */
    ensureViewModel(context: CompositionContext): Promise<CompositionContext>;
    
    /**
      * Dynamically composes a component.
      * @param context The CompositionContext providing information on how the composition should occur.
      * @return A Promise for the View or the Controller that results from the dynamic composition.
      */
    compose(context: CompositionContext): Promise<View | Controller>;
  }
  
  /**
  * Identifies a class as a resource that configures the EventManager with information
  * about how events relate to properties for the purpose of two-way data-binding
  * to Web Components.
  */
  export class ElementConfigResource {
    
    /**
      * Provides an opportunity for the resource to initialize iteself.
      * @param container The dependency injection container from which the resource
      * can aquire needed services.
      * @param target The class to which this resource metadata is attached.
      */
    initialize(container: Container, target: Function): void;
    
    /**
      * Allows the resource to be registered in the view resources for the particular
      * view into which it was required.
      * @param registry The view resource registry for the view that required this resource.
      * @param name The name provided by the end user for this resource, within the
      * particular view it's being used.
      */
    register(registry: ViewResources, name?: string): void;
    
    /**
      * Enables the resource to asynchronously load additional resources.
      * @param container The dependency injection container from which the resource
      * can aquire needed services.
      * @param target The class to which this resource metadata is attached.
      */
    load(container: Container, target: Function): void;
  }
  
  /**
  * Decorator: Specifies a resource instance that describes the decorated class.
  * @param instance The resource instance.
  */
  export function resource(instance: Object): any;
  
  /**
  * Decorator: Specifies a custom HtmlBehaviorResource instance or an object that overrides various implementation details of the default HtmlBehaviorResource.
  * @param override The customized HtmlBehaviorResource or an object to override the default with.
  */
  export function behavior(override: HtmlBehaviorResource | Object): any;
  
  /**
  * Decorator: Indicates that the decorated class is a custom element.
  * @param name The name of the custom element.
  */
  export function customElement(name: string): any;
  
  /**
  * Decorator: Indicates that the decorated class is a custom attribute.
  * @param name The name of the custom attribute.
  * @param defaultBindingMode The default binding mode to use when the attribute is bound wtih .bind.
  */
  export function customAttribute(name: string, defaultBindingMode?: number): any;
  
  /**
  * Decorator: Applied to custom attributes. Indicates that whatever element the
  * attribute is placed on should be converted into a template and that this
  * attribute controls the instantiation of the template.
  */
  export function templateController(target?: any): any;
  
  /**
  * Decorator: Specifies that a property is bindable through HTML.
  * @param nameOrConfigOrTarget The name of the property, or a configuration object.
  */
  export function bindable(nameOrConfigOrTarget?: string | Object, key?: any, descriptor?: any): any;
  
  //placed on a class
  /**
  * Decorator: Specifies that the decorated custom attribute has options that
  * are dynamic, based on their presence in HTML and not statically known.
  */
  export function dynamicOptions(target?: any): any;
  
  /**
  * Decorator: Indicates that the custom element should render its view in Shadow
  * DOM. This decorator may change slightly when Aurelia updates to Shadow DOM v1.
  */
  export function useShadowDOM(target?: any): any;
  
  /**
  * Decorator: Enables custom processing of the attributes on an element before the framework inspects them.
  * @param processor Pass a function which can provide custom processing of the content.
  */
  export function processAttributes(processor: Function): any;
  
  /**
  * Decorator: Enables custom processing of the content that is places inside the
  * custom element by its consumer.
  * @param processor Pass a boolean to direct the template compiler to not process
  * the content placed inside this element. Alternatively, pass a function which
  * can provide custom processing of the content. This function should then return
  * a boolean indicating whether the compiler should also process the content.
  */
  export function processContent(processor: boolean | Function): any;
  
  /**
  * Decorator: Indicates that the custom element should be rendered without its
  * element container.
  */
  export function containerless(target?: any): any;
  
  /**
  * Decorator: Associates a custom view strategy with the component.
  * @param strategy The view strategy instance.
  */
  export function useViewStrategy(strategy: Object): any;
  
  /**
  * Decorator: Provides a relative path to a view for the component.
  * @param path The path to the view.
  */
  export function useView(path: string): any;
  
  /**
  * Decorator: Provides a view template, directly inline, for the component. Be
  * sure to wrap the markup in a template element.
  * @param markup The markup for the view.
  * @param dependencies A list of dependencies that the template has.
  * @param dependencyBaseUrl A base url from which the dependencies will be loaded.
  */
  export function inlineView(markup: string, dependencies?: Array<string | Function | Object>, dependencyBaseUrl?: string): any;
  
  /**
  * Decorator: Indicates that the component has no view.
  */
  export function noView(target?: any): any;
  
  /**
  * Decorator: Indicates that the decorated class provides element configuration
  * to the EventManager for one or more Web Components.
  */
  export function elementConfig(target?: any): any;
  
  /**
  * A facade of the templating engine capabilties which provides a more user friendly API for common use cases.
  */
  
  /**
  * A facade of the templating engine capabilties which provides a more user friendly API for common use cases.
  */
  export class TemplatingEngine {
    
    /**
      * Creates an instance of TemplatingEngine.
      * @param container The root DI container.
      * @param moduleAnalyzer The module analyzer for discovering view resources.
      * @param viewCompiler The view compiler for compiling views.
      * @param compositionEngine The composition engine used during dynamic component composition.
      */
    constructor(container: Container, moduleAnalyzer: ModuleAnalyzer, viewCompiler: ViewCompiler, compositionEngine: CompositionEngine);
    
    /**
       * Configures the default animator.
       * @param animator The animator instance.
       */
    configureAnimator(animator: Animator): void;
    
    /**
       * Dynamically composes components and views.
       * @param context The composition context to use.
       * @return A promise for the resulting Controller or View. Consumers of this API
       * are responsible for enforcing the Controller/View lifecycle.
       */
    compose(context: CompositionContext): Promise<View | Controller>;
    
    /**
       * Enhances existing DOM with behaviors and bindings.
       * @param instruction The element to enhance or a set of instructions for the enhancement process.
       * @return A View representing the enhanced UI. Consumers of this API
       * are responsible for enforcing the View lifecycle.
       */
    enhance(instruction: Element | EnhanceInstruction): View;
    
    /**
       * Creates a behavior's controller for use in unit testing.
       * @param viewModelType The constructor of the behavior view model to test.
       * @param attributesFromHTML A key/value lookup of attributes representing what would be in HTML (values can be literals or binding expressions).
       * @return The Controller of the behavior.
       */
    createControllerForUnitTest(viewModelType: Function, attributesFromHTML?: Object): Controller;
    
    /**
       * Creates a behavior's view model for use in unit testing.
       * @param viewModelType The constructor of the behavior view model to test.
       * @param attributesFromHTML A key/value lookup of attributes representing what would be in HTML (values can be literals or binding expressions).
       * @param bindingContext
       * @return The view model instance.
       */
    createViewModelForUnitTest(viewModelType: Function, attributesFromHTML?: Object, bindingContext?: any): Object;
  }
}
}
declare module 'aurelia-templating' {
export * from '~aurelia-templating-resources~aurelia-templating/dist/commonjs/aurelia-templating';
}

// Generated by typings
// Source: node_modules/aurelia-binding/dist/commonjs/aurelia-binding.d.ts
declare module '~aurelia-templating-resources~aurelia-binding/dist/commonjs/aurelia-binding' {
/**
 * A modern databinding library for JavaScript and HTML.
 */
module 'aurelia-binding' {
  import { Container } from 'aurelia-dependency-injection';

  /**
   * The "parallel" or "artificial" aspect of the binding scope. Provides access to the parent binding
   * context and stores contextual bindable members such as $event, $index, $odd, etc. Members on this
   * object take precedence over members of the bindingContext object.
   */
  export interface OverrideContext {
    parentOverrideContext: OverrideContext;
    bindingContext: any;
  }

  /**
   * The two part binding scope. The first part is the bindingContext which represents the primary scope, typically a
   * view-model instance and second the overrideContext
   */
  export interface Scope {
    /**
     * The primary aspect of the binding scope.  Typically a view-model instance.
     */
    bindingContext: any;
    /**
     * The "parallel" or "artificial" aspect of the binding scope. Provides access to the parent binding
     * context and stores contextual bindable members such as $event, $index, $odd, etc. Members on this
     * object take precedence over members of the bindingContext object.
     */
    overrideContext: OverrideContext;
  }

  /**
   * Provides a mechanism for releasing resources.
   */
  export interface Disposable {
    /**
     * Performs tasks associated with freeing, releasing, or resetting resources.
     */
    dispose(): void;
  }

  /**
   * Creates an overrideContext object with the supplied bindingContext and optional parent overrideContext.
   */
  export function createOverrideContext(bindingContext: any, parentOverrideContext?: OverrideContext): OverrideContext;

  /**
   * Creates a scope object for testing purposes.
   */
  export function createScopeForTest(bindingContext: any, parentBindingContext?: any): Scope;

  /**
   * A ValueConverter resource.
   */
  export class ValueConverterResource {
    static convention(name: string): ValueConverterResource;
    constructor(name: string);
    initialize(container: Container, target: any): void;
    register(registry: any, name: string): void;
  }

  /**
   * A BindingBehavior resource.
   */
  export class BindingBehaviorResource {
    static convention(name: string): BindingBehaviorResource;
    constructor(name: string);
    initialize(container: Container, target: any): void;
    register(registry: any, name: string): void;
  }

  /**
   * Decorator: Adds efficient subscription management methods to the decorated class's prototype.
   */
  export function subscriberCollection(): any;

  /**
   * Subscribes to appropriate element events based on the element property
   * being observed for changes.
   * This is an internal API and is subject to change without notice in future releases.
   */
  export class EventManager {
    registerElementConfig(config: { tagName: string; properties: { (s: string): string[] }; }): void;
    /**
     * Subscribes to specified event on the target element.
     * @param target Target element.
     * @param targetEvent Name of event to subscribe.
     * @param callback Event listener callback.
     * @param delegate True to use event delegation mechanism.
     * @returns function wich removes event listener.
     */
    addEventListener(target: Element, targetEvent: string, callback: (event: Event) => any, delegate: boolean): () => void;
  }

  /**
   * Observes property changes.
   */
  export interface PropertyObserver {
    /**
     * Subscribe to property change events.
     */
    subscribe(callback: (newValue: any, oldValue: any) => void): Disposable;
  }

  /**
   * Observes collection mutation.
   */
  export interface CollectionObserver {
    /**
     * Subscribe to collection mutation events.
     */
    subscribe(callback: (changeRecords: any) => void): Disposable;
  }

  /**
   * Describes the direction of the data flow in a binding.
   */
  export enum bindingMode {
    /**
     * Updates the binding target once. This is essentially a simpler form of one-way binding
     * that provides better performance in cases where the source value does not change.
     */
    oneTime = 0,
    /**
     * Updates the binding target (target) property when the binding source (source) changes.
     * This type of binding is appropriate if the element being bound is implicitly read-only.
     * If there is no need to monitor the changes of the target property, using the OneWay
     * binding mode avoids the overhead of the two-way binding mode.
     */
    oneWay = 1,
    /**
     * Causes changes to either the source property or the target property to automatically update
     * the other. This type of binding is appropriate for editable forms or other fully-interactive
     * UI scenarios.
     */
    twoWay = 2
  }

  /**
   * Lookup functions for value converter and binding behavior resources.
   */
  export interface LookupFunctions {
    bindingBehaviors(name: string): any;
    valueConverters(name: string): any;
  }

  /**
   * A callable object.
   */
  export interface Callable {
    call(context: any, newValue: any, oldValue: any): void;
    call(context: any, changeRecords: any): void;
  }

  /**
   * Observes property changes.
   */
  export interface InternalPropertyObserver {
    /**
     * Gets the property value.
     */
    getValue(): any;
    /**
     * Sets the property value.
     */
    setValue(newValue: any): void;
    /**
     * Subscribe to property changes with a callback function.
     */
    subscribe(callback: (newValue: any, oldValue: any) => void): void;
    /**
     * Subscribe a callable object to property changes.
     * @param context A value to be passed to the callable object's call function when a property change occurs.
     * @param callable A callable object.
     */
    subscribe(context: any, callable: Callable): void;
    /**
     * Unsubscribes a callback function from property changes.
     */
    unsubscribe(callback: (newValue: any, oldValue: any) => void): void;
    /**
     * Unsubscribes a callable object from property changes.
     * @param context A value to be passed to the callable object's call function when a property change occurs.
     * @param callable A callable object.
     */
    unsubscribe(context: any, callable: Callable): void;
  }

  /**
   * Observes collection mutation.
   */
  export interface InternalCollectionObserver {
    /**
     * Subscribe to collection mutation events with a callback function.
     */
    subscribe(callback: (changeRecords: any) => void): void;
    /**
     * Subscribe a callable object to collection mutation events.
     * @param context A value to be passed to the callable object's call function when collection mutation occurs.
     * @param callable A callable object.
     */
    subscribe(context: any, callable: Callable): void;
    /**
     * Unsubscribes a callback function from collection mutation changes.
     */
    unsubscribe(callback: (changeRecords: any) => void): void;
    /**
     * Unsubscribes a callable object from collection mutation events.
     * @param context A value to be passed to the callable object's call function when collection mutation occurs.
     * @param callable A callable object.
     */
    unsubscribe(context: any, callable: Callable): void;
  }

  /**
   * Provides high-level access to the definition of a binding, which connects the properties of
   * binding target objects (typically, HTML elements), and any data source
   */
  export interface Binding {
    /**
     * The directionality of the binding.
     */
    mode?: bindingMode;
    /**
     * The expression to access/assign/connect the binding source property.
     */
    sourceExpression?: Expression;
    /**
     * Assigns a value to the target.
     */
    updateTarget?: (value: any) => void;
    /**
     * Assigns a value to the source.
     */
    updateSource?: (value: any) => void;
    /**
     * Calls the source method with the specified args object.
     */
    callSource?: (event: any) => any;
    /**
     * Connects the binding to a scope.
     */
    bind(source: Scope): void;
    /**
     * Disconnects the binding from a scope.
     */
    unbind(): void;
  }

  /**
   * A factory for binding instances.
   */
  export interface BindingExpression {
    createBinding(target: any): Binding;
  }

  /**
   * Provides the base class from which the classes that represent expression tree nodes are derived.
   */
  export interface Expression {
    /**
     * Evaluates the expression using the provided scope and lookup functions.
     */
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    /**
     * Assigns a value to the property represented by the expression.
     */
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    /**
     * Subscribes a binding instance to the property change events along the path of the expression.
     */
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * A binding behavior expression.
   */
  export class BindingBehavior implements Expression {
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * A value converter expression.
   */
  export class ValueConverter implements Expression {
    evaluate(scope: Scope, lookupFunctions: LookupFunctions): any;
    assign(scope: Scope, value: any, lookupFunctions: LookupFunctions): void;
    connect(binding: Binding, scope: Scope): void;
  }

  /**
   * Parses strings containing javascript expressions and returns a data-binding specialized AST.
   */
  export class Parser {
    /**
     * Parses a string containing a javascript expression and returns a data-binding specialized AST. Memoized.
     */
    parse(input: string): Expression;
  }

  /**
   * Provides efficient property observers for properties that would otherwise require dirty-checking.
   */
  export interface ObjectObservationAdapter {
    getObserver(object: any, propertyName: string, descriptor: PropertyDescriptor): InternalPropertyObserver;
  }

  /**
   * Internal object observation API. Locates observers for properties, arrays and maps using a variety of strategies.
   */
  export class ObserverLocator {
    /**
     * Gets an observer for property changes.
     */
    getObserver(obj: any, propertyName: string): InternalPropertyObserver;
    /**
     * Adds a property observation adapter.
     */
    addAdapter(adapter: ObjectObservationAdapter): void;
    /**
     * Gets an observer for array mutation.
     */
    getArrayObserver(array: Array<any>): InternalCollectionObserver;
    /**
     * Gets an observer for map mutation.
     */
    getMapObserver(map: Map<any, any>): InternalCollectionObserver;
  }

  /**
   * Binding system API.
   */
  export class BindingEngine {
    /**
     * Creates a binding expression for the specified target property and source expression.
     * @param targetProperty The target attribute, eg "value" / "checked" / "textcontent" / "data-foo".
     * @param sourceExpression A javascript expression accessing the source property.
     * @param mode The directionality of the binding.
     * @param lookupFunctions Lookup functions for value converter and binding behavior resources.
     */
    createBindingExpression(targetProperty: string, sourceExpression: string, mode?: bindingMode, lookupFunctions?: LookupFunctions): BindingExpression;
    /**
     * Gets an observer for property changes.
     */
    propertyObserver(obj: Object, propertyName: string): PropertyObserver;
    /**
     * Gets an observer for collection mutation.
     */
    collectionObserver(collection: Array<any> | Map<any, any>): CollectionObserver;
    /**
     * Gets an observer for a javascript expression that accesses a property on the binding context.
     * @param bindingContext The binding context (view-model)
     * @param expression A javascript expression accessing the source property.
     */
    expressionObserver(bindingContext: any, expression: string): PropertyObserver;
    /**
     * Parses a string containing a javascript expression and returns a data-binding specialized AST. Memoized.
     */
    parseExpression(expression: string): Expression;
    /**
     * Registers an adapter that provides an efficient property observeration strategy for
     * properties that would otherwise require dirty-checking.
     */
    registerAdapter(adapter: ObjectObservationAdapter): void;
  }

  /**
   * Returns whether a property's dependencies have been declared.
   */
  export function hasDeclaredDependencies(descriptor: PropertyDescriptor): boolean;

  /**
   * Declares a property's dependencies.
   */
  export function declarePropertyDependencies(ctor: any, propertyName: string, dependencies: string[]): void;

 /**
  * Decorator: Indicates that the decorated property is computed from other properties.
  * @param propertyNames The names of the properties the decorated property is computed from.  Simple property names, not expressions.
  */
  export function computedFrom(...propertyNames: string[]): any;

 /**
  * Decorator: Indicates that the decorated class is a value converter.
  * @param name The name of the value converter.
  */
  export function valueConverter(name: string): any;

 /**
  * Decorator: Indicates that the decorated class is a binding behavior.
  * @param name The name of the binding behavior.
  */
  export function bindingBehavior(name: string): any;

  /**
   * A context used when invoking a binding's callable API to notify
   * the binding that the context is a "source update".
   */
  export const sourceContext: string;

  /**
   * An internal API used by Aurelia's array observation components.
   */
  export function getChangeRecords(): any;

  /**
   * An internal API used by Aurelia's array observation components.
   */
  export function mergeSplice(splices: any, index: number, removed: any, addedCount: number): any;
  
  /**
  * Decorator: Specifies that a property is observable.
  * @param targetOrConfig The name of the property, or a configuration object.
  */
  export function observable(targetOrConfig?: Object, key?: any, descriptor?: any): any;
}
}
declare module 'aurelia-binding' {
export * from '~aurelia-templating-resources~aurelia-binding/dist/commonjs/aurelia-binding';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module 'aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-task-queue~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-task-queue~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-task-queue~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-task-queue/dist/commonjs/aurelia-task-queue.d.ts
declare module '~aurelia-templating-resources~aurelia-task-queue/dist/commonjs/aurelia-task-queue' {
module 'aurelia-task-queue' {
  import {
    DOM,
    FEATURE
  } from '~aurelia-templating-resources~aurelia-task-queue~aurelia-pal';
  
  /**
  * Either a Function or a class with a call method that will do work when dequeued.
  */
  export interface Task {
    
    /**
      * Call it.
      */
    call(): void;
  }
  
  /**
  * Implements an asynchronous task queue.
  */
  /**
  * Implements an asynchronous task queue.
  */
  export class TaskQueue {
    
    /**
      * Creates an instance of TaskQueue.
      */
    constructor();
    
    /**
      * Queues a task on the micro task queue for ASAP execution.
      * @param task The task to queue up for ASAP execution.
      */
    queueMicroTask(task: Task | Function): void;
    
    /**
      * Queues a task on the macro task queue for turn-based execution.
      * @param task The task to queue up for turn-based execution.
      */
    queueTask(task: Task | Function): void;
    
    /**
      * Immediately flushes the task queue.
      */
    flushTaskQueue(): void;
    
    /**
      * Immediately flushes the micro task queue.
      */
    flushMicroTaskQueue(): void;
  }
}
}
declare module 'aurelia-task-queue' {
export * from '~aurelia-templating-resources~aurelia-task-queue/dist/commonjs/aurelia-task-queue';
}

// Generated by typings
// Source: node_modules/aurelia-path/dist/commonjs/aurelia-path.d.ts
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-path/dist/commonjs/aurelia-path' {
module 'aurelia-path' {
  
  /**
  * Calcualtes a path relative to a file.
  *
  * @param name The relative path.
  * @param file The file path.
  * @return The calcualted path.
  */
  export function relativeToFile(name: string, file: string): string;
  
  /**
  * Joins two paths.
  *
  * @param path1 The first path.
  * @param path2 The second path.
  * @return The joined path.
  */
  export function join(path1: string, path2: string): string;
  
  /**
  * Generate a query string from an object.
  *
  * @param params Object containing the keys and values to be used.
  * @returns The generated query string, excluding leading '?'.
  */
  export function buildQueryString(params: Object): string;
  
  /**
  * Parse a query string.
  *
  * @param queryString The query string to parse.
  * @returns Object with keys and values mapped from the query string.
  */
  export function parseQueryString(queryString: string): Object;
}
}
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-path' {
export * from '~aurelia-templating-resources~aurelia-loader~aurelia-path/dist/commonjs/aurelia-path';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-loader~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-loader~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module '~aurelia-templating-resources~aurelia-loader~aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-loader~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-loader/dist/commonjs/aurelia-loader.d.ts
declare module '~aurelia-templating-resources~aurelia-loader/dist/commonjs/aurelia-loader' {
module 'aurelia-loader' {
  import {
    relativeToFile
  } from '~aurelia-templating-resources~aurelia-loader~aurelia-path';
  import {
    Origin
  } from '~aurelia-templating-resources~aurelia-loader~aurelia-metadata';
  
  /*eslint no-unused-vars:0*/
  /**
  * Represents a plugin to the module loader.
  */
  export interface LoaderPlugin {
    
    /**
      * Fetches the resource.
      * @param address The address of the resource.
      * @return A Promise for the requested resouce.
      */
    fetch(address: string): Promise<any>;
  }
  
  /**
  * Represents a dependency of a template.
  */
  export class TemplateDependency {
    
    /**
      * The source of the dependency.
      */
    src: string;
    
    /**
      * The local name of the src when used in the template.
      */
    name: string;
    
    /**
      * Creates a template dependency.
      * @param src The source of the dependency.
      * @param name The local name of the src when used in the template.
      */
    constructor(src: string, name?: string);
  }
  
  /**
  * Represents an entry in the template registry.
  */
  export class TemplateRegistryEntry {
    
    /**
      * The address of the template that this entry represents.
      */
    address: string;
    
    /**
      * Indicates whether or not the associated template is loaded .
      */
    templateIsLoaded: boolean;
    
    /**
      * Indicates whether the factory is ready to be used to create instances of the associated template.
      */
    factoryIsReady: boolean;
    
    /**
      * Sets the resources associated with this entry.
      */
    resources: Object;
    
    /**
      * The dependencies of the associated template. Dependencies are not available until after the template is loaded.
      */
    dependencies: TemplateDependency[];
    
    /**
      * Creates an instance of TemplateRegistryEntry.
      * @param address The address of the template that this entry represents.
      */
    constructor(address: string);
    
    /**
      * Gets the template for this registry entry.
      */
    template: Element;
    
    /**
      * Gets the factory capable of creating instances of this template.
      */
    factory: any;
    
    /**
      * Adds a dependency to this template registry entry. Cannot be called until after the template is set.
      * @param src The dependency instance or a relative path to its module.
      * @param name An optional local name by which this dependency is used in the template.
      */
    addDependency(src: string | Function, name?: string): void;
  }
  
  /**
  * A generic resource loader, for loading modules, html, css and more.
  */
  /**
  * A generic resource loader, for loading modules, html, css and more.
  */
  export class Loader {
    
    /**
      * Creates an instance of Loader.
      */
    constructor();
    
    /**
      * Maps a module id to a source.
      * @param id The module id.
      * @param source The source to map the module to.
      */
    map(id: string, source: string): void;
    
    /**
      * Normalizes a module id.
      * @param moduleId The module id to normalize.
      * @param relativeTo What the module id should be normalized relative to.
      * @return The normalized module id.
      */
    normalizeSync(moduleId: string, relativeTo: string): string;
    
    /**
      * Normalizes a module id.
      * @param moduleId The module id to normalize.
      * @param relativeTo What the module id should be normalized relative to.
      * @return A promise for the normalized module id.
      */
    normalize(moduleId: string, relativeTo: string): Promise<string>;
    
    /**
      * Loads a module.
      * @param id The module id to normalize.
      * @return A Promise for the loaded module.
      */
    loadModule(id: string): Promise<any>;
    
    /**
      * Loads a collection of modules.
      * @param ids The set of module ids to load.
      * @return A Promise for an array of loaded modules.
      */
    loadAllModules(ids: string[]): Promise<any[]>;
    
    /**
      * Loads a template.
      * @param url The url of the template to load.
      * @return A Promise for a TemplateRegistryEntry containing the template.
      */
    loadTemplate(url: string): Promise<TemplateRegistryEntry>;
    
    /**
      * Loads a text-based resource.
      * @param url The url of the text file to load.
      * @return A Promise for text content.
      */
    loadText(url: string): Promise<string>;
    
    /**
      * Alters a module id so that it includes a plugin loader.
      * @param url The url of the module to load.
      * @param pluginName The plugin to apply to the module id.
      * @return The plugin-based module id.
      */
    applyPluginToUrl(url: string, pluginName: string): string;
    
    /**
      * Registers a plugin with the loader.
      * @param pluginName The name of the plugin.
      * @param implementation The plugin implementation.
      */
    addPlugin(pluginName: string, implementation: LoaderPlugin): void;
    
    /**
      * Gets or creates a TemplateRegistryEntry for the provided address.
      * @param address The address of the template.
      * @return The located or created TemplateRegistryEntry.
      */
    getOrCreateTemplateRegistryEntry(address: string): TemplateRegistryEntry;
  }
}
}
declare module 'aurelia-loader' {
export * from '~aurelia-templating-resources~aurelia-loader/dist/commonjs/aurelia-loader';
}

// Generated by typings
// Source: node_modules/aurelia-path/dist/commonjs/aurelia-path.d.ts
declare module '~aurelia-templating-resources~aurelia-path/dist/commonjs/aurelia-path' {
module 'aurelia-path' {
  
  /**
  * Calcualtes a path relative to a file.
  *
  * @param name The relative path.
  * @param file The file path.
  * @return The calcualted path.
  */
  export function relativeToFile(name: string, file: string): string;
  
  /**
  * Joins two paths.
  *
  * @param path1 The first path.
  * @param path2 The second path.
  * @return The joined path.
  */
  export function join(path1: string, path2: string): string;
  
  /**
  * Generate a query string from an object.
  *
  * @param params Object containing the keys and values to be used.
  * @returns The generated query string, excluding leading '?'.
  */
  export function buildQueryString(params: Object): string;
  
  /**
  * Parse a query string.
  *
  * @param queryString The query string to parse.
  * @returns Object with keys and values mapped from the query string.
  */
  export function parseQueryString(queryString: string): Object;
}
}
declare module 'aurelia-path' {
export * from '~aurelia-templating-resources~aurelia-path/dist/commonjs/aurelia-path';
}

// Generated by typings
// Source: node_modules/aurelia-pal/dist/commonjs/aurelia-pal.d.ts
declare module '~aurelia-templating-resources~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal' {
module 'aurelia-pal' {
  
  /**
  * Enables discovery of what features the runtime environment supports.
  */
  export interface Feature {
    
    /**
      * Does the runtime environment support ShadowDOM?
      */
    shadowDOM: boolean;
    
    /**
      * Does the runtime environment support the css scoped attribute?
      */
    scopedCSS: boolean;
    
    /**
      * Does the runtime environment support native HTMLTemplateElement?
      */
    htmlTemplateElement: boolean;
    
    /**
      * Does the runtime environment support native DOM mutation observers?
      */
    mutationObserver: boolean;
  }
  
  /**
  * The runtime's performance API.
  */
  export interface Performance {
    now(): number;
  }
  
  /**
  * Represents the core APIs of the runtime environment.
  */
  /**
  * Represents the core APIs of the runtime environment.
  */
  export interface Platform {
    
    /**
      * The runtime environment's global.
      */
    global: any;
    
    /**
      * A function wich does nothing.
      */
    noop: Function;
    
    /**
      * The runtime's location API.
      */
    location: Object;
    
    /**
      * The runtime's history API.
      */
    history: Object;
    
    /**
      * The runtime's performance API
      */
    performance: Performance;
    
    /**
      * Registers a function to call when the system is ready to update (repaint) the display.
      * @param callback The function to call.
      */
    requestAnimationFrame(callback: ((animationFrameStart: number) => void)): number;
    
    /**
      * The runtime's XMLHttpRequest API.
      */
    XMLHttpRequest: XMLHttpRequest;
    
    /**
      * Iterate all modules loaded by the script loader.
      * @param callback A callback that will receive each module id along with the module object. Return true to end enumeration.
      */
    eachModule(callback: ((key: string, value: Object) => boolean)): void;
    
    /**
      * Add a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture?: boolean): void;
    
    /**
      * Remove a global event listener.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture?: boolean): void;
  }
  
  /**
  * Represents the core APIs of the DOM.
  */
  export interface Dom {
    
    /**
      * The global DOM Element type.
      */
    Element: Element;
    
    /**
      * The global DOM SVGElement type.
      */
    SVGElement: SVGElement;
    
    /**
      * A key representing a DOM boundary.
      */
    boundary: string;
    
    /**
      * The document title.
      */
    title: string;
    
    /**
      * The document's active/focused element.
      */
    activeElement: Element;
    
    /**
      * Add an event listener to the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function that receives a notification when an event of the specified type occurs.
      * @param capture If true, useCapture indicates that the user wishes to initiate capture.
      */
    addEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Remove an event listener from the document.
      * @param eventName A string representing the event type to listen for.
      * @param callback The function to remove from the event.
      * @param capture Specifies whether the listener to be removed was registered as a capturing listener or not.
      */
    removeEventListener(eventName: string, callback: Function, capture: boolean): void;
    
    /**
      * Adopts a node from an external document.
      * @param node The node to be adopted.
      * @return The adopted node able to be used in the document.
      */
    adoptNode(node: Node): Node;
    
    /**
      * Creates the specified HTML element or an HTMLUnknownElement if the given element name isn't a known one.
      * @param tagName A string that specifies the type of element to be created.
      * @return The created element.
      */
    createElement(tagName: string): Element;
    
    /**
      * Creates a new Text node.
      * @param text A string to populate the new Text node.
      * @return A Text node.
      */
    createTextNode(text: string): Text;
    
    /**
      * Creates a new Comment node.
      * @param text A string to populate the new Comment node.
      * @return A Comment node.
      */
    createComment(text: string): Comment;
    
    /**
      * Creates a new DocumentFragment.
      * @return A DocumentFragment.
      */
    createDocumentFragment(): DocumentFragment;
    
    /**
      * Creates a new MutationObserver.
      * @param callback A callback that will recieve the change records with the mutations.
      * @return A MutationObservere.
      */
    createMutationObserver(callback: Function): MutationObserver;
    
    /**
      * Creates a new CustomEvent.
      * @param eventType A string representing the event type.
      * @param options An options object specifying bubbles:boolean, cancelable:boolean and/or detail:Object information.
      * @return A CustomEvent.
      */
    createCustomEvent(eventType: string, options: Object): CustomEvent;
    
    /**
      * Dispatches an event on the document.
      * @param evt The event to dispatch.
      */
    dispatchEvent(evt: Event): void;
    
    /**
      * Gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.
      * @param element The Element for which to get the computed style.
      * @return The computed styles.
      */
    getComputedStyle(element: Element): CSSStyleDeclaration;
    
    /**
      * Locates an element in the document according to its id.
      * @param id The id to search the document for.
      * @return The found element.
      */
    getElementById(id: string): Element;
    
    /**
      * Performs a query selector on the document and returns all located matches.
      * @param query The query to use in searching the document.
      * @return A list of all matched elements in the document.
      */
    querySelectorAll(query: string): NodeList;
    
    /**
      * Gets the element that is the next sibling of the provided element.
      * @param element The element whose next sibling is being located.
      * @return The next sibling Element of the provided Element.
      */
    nextElementSibling(element: Node): Element;
    
    /**
      * Creates an HTMLTemplateElement using the markup provided.
      * @param markup A string containing the markup to turn into a template. Note: This string must contain the template element as well.
      * @return The instance of HTMLTemplateElement that was created from the provided markup.
      */
    createTemplateFromMarkup(markup: string): Element;
    
    /**
      * Appends a node to the parent, if provided, or the document.body otherwise.
      * @param newNode The node to append.
      * @param parentNode The node to append to, otherwise the document.body.
      */
    appendNode(newNode: Node, parentNode?: Node): void;
    
    /**
      * Replaces a node in the parent with a new node.
      * @param newNode The node to replace the old node with.
      * @param node The node that is being replaced.
      * @param parentNode The node that the current node is parented to.
      */
    replaceNode(newNode: Node, node: Node, parentNode?: Node): void;
    
    /**
      * Removes the specified node from the parent node.
      * @param node The node to remove.
      * @param parentNode The parent node from which the node will be removed.
      */
    removeNode(node: Node, parentNode?: Node): void;
    
    /**
      * Injects styles into the destination element, or the document.head if no destination is provided.
      * @param styles The css text to injext.
      * @param destination The destination element to inject the css text into. If not specified it will default to the document.head.
      * @param prepend Indicates whether or not the styles should be prepended to the destination. By default they are appended.
      * @return The Style node that was created.
      */
    injectStyles(styles: string, destination?: Element, prepend?: boolean): Node;
  }
  
  /**
  * Creates an instance of Error that aggregates and preserves an innerError.
  * @param message The error message.
  * @param innerError The inner error message to aggregate.
  * @param skipIfAlreadyAggregate Indicates to not wrap the inner error if it itself already has an innerError.
  * @return The Error instance.
  */
  export function AggregateError(message: string, innerError?: Error, skipIfAlreadyAggregate?: boolean): Error;
  
  /**
  * The singleton instance of the Feature discovery API.
  */
  /**
  * The singleton instance of the Feature discovery API.
  */
  export const FEATURE: Feature;
  
  /**
  * The singleton instance of the Platform API.
  */
  /**
  * The singleton instance of the Platform API.
  */
  export const PLATFORM: Platform;
  
  /**
  * The singleton instance of the Dom API.
  */
  /**
  * The singleton instance of the Dom API.
  */
  export const DOM: Dom;
  
  /**
  * Enables initializing a specific implementation of the Platform Abstraction Layer (PAL).
  * @param callback Allows providing a callback which configures the three PAL singletons with their platform-specific implementations.
  */
  export function initializePAL(callback: ((platform: Platform, feature: Feature, dom: Dom) => void)): void;
}
}
declare module '~aurelia-templating-resources~aurelia-metadata~aurelia-pal' {
export * from '~aurelia-templating-resources~aurelia-metadata~aurelia-pal/dist/commonjs/aurelia-pal';
}

// Generated by typings
// Source: node_modules/aurelia-metadata/dist/commonjs/aurelia-metadata.d.ts
declare module '~aurelia-templating-resources~aurelia-metadata/dist/commonjs/aurelia-metadata' {
module 'aurelia-metadata' {
  import {
    PLATFORM
  } from '~aurelia-templating-resources~aurelia-metadata~aurelia-pal';
  
  /**
  * Helpers for working with metadata on functions.
  */
  export interface MetadataType {
    
    /**
      * The metadata key representing pluggable resources.
      */
    resource: string;
    
    /**
      * The metadata key representing parameter type information.
      */
    paramTypes: string;
    
    /**
      * The metadata key representing property information.
      */
    properties: string;
    
    /**
      * Gets metadata specified by a key on a target, searching up the inheritance hierarchy.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    get(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Gets metadata specified by a key on a target, only searching the own instance.
      * @param metadataKey The key for the metadata to lookup.
      * @param target The target to lookup the metadata on.
      * @param targetKey The member on the target to lookup the metadata on.
      */
    getOwn(metadataKey: string, target: Function, targetKey: string): Object;
    
    /**
      * Defines metadata specified by a key on a target.
      * @param metadataKey The key for the metadata to define.
      * @param target The target to set the metadata on.
      * @param targetKey The member on the target to set the metadata on.
      */
    define(metadataKey: string, metadataValue: Object, target: Function, targetKey: string): void;
    
    /**
      * Gets metadata specified by a key on a target, or creates an instance of the specified metadata if not found.
      * @param metadataKey The key for the metadata to lookup or create.
      * @param Type The type of metadata to create if existing metadata is not found.
      * @param target The target to lookup or create the metadata on.
      * @param targetKey The member on the target to lookup or create the metadata on.
      */
    getOrCreateOwn(metadataKey: string, Type: Function, target: Function, targetKey: string): Object;
  }
  
  /**
  * An object capable of applying it's captured decorators to a target.
  */
  export interface DecoratorApplicator {
    
    /**
      * Applies the decorators to the target.
      * @param target The target.
      * @param key If applying to a method, the member name.
      * @param key If applying to a method, you may supply an initial descriptor to pass to the decorators.
      */
    on(target: any, key?: string, descriptor?: Object): any;
  }
  
  /**
  * Options that control how the deprected decorator should function at runtime.
  */
  export interface DeprecatedOptions {
    
    /**
      * Specifies a custom deprecation message.
      */
    message: string;
    
    /**
      * Specifies whether or not the deprecation should throw an error.
      */
    error: boolean;
  }
  
  /**
  * Options used during protocol creation.
  */
  export interface ProtocolOptions {
    
    /**
      * A function that will be run to validate the decorated class when the protocol is applied. It is also used to validate adhoc instances.
      * If the validation fails, a message should be returned which directs the developer in how to address the issue.
      */
    validate?: (target: any) => string | boolean;
    
    /**
      * A function which has the opportunity to compose additional behavior into the decorated class when the protocol is applied.
      */
    compose?: (target: any) => void;
  }
  
  /**
  * Provides helpers for working with metadata.
  */
  /**
  * Provides helpers for working with metadata.
  */
  export const metadata: MetadataType;
  
  /**
  * A metadata annotation that describes the origin module of the function to which it's attached.
  */
  export class Origin {
    
    /**
      * The id of the module from which the item originated.
      */
    moduleId: string;
    
    /**
      * The member name of the export on the module object from which the item originated.
      */
    moduleMember: string;
    
    /**
      * Creates an instance of Origin metadata.
      * @param moduleId The id of the module from which the item originated.
      * @param moduleMember The member name of the export on the module object from which the item originated.
      */
    constructor(moduleId: string, moduleMember: string);
    
    /**
      * Get the Origin metadata for the specified function.
      * @param fn The function to inspect for Origin metadata.
      * @return Returns the Origin metadata.
      */
    static get(fn: Function): Origin;
    
    /**
      * Set the Origin metadata for the specified function.
      * @param fn The function to set the Origin metadata on.
      * @param fn The Origin metadata to store on the function.
      * @return Returns the Origin metadata.
      */
    static set(fn: Function, origin: Origin): void;
  }
  
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  /**
  * Enables applying decorators, particularly for use when there is no syntax support in the language, such as with ES5 and ES2016.
  * @param rest The decorators to apply.
  */
  export function decorators(...rest: Function[]): DecoratorApplicator;
  
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  /**
  * Decorator: Enables marking methods as deprecated.
  * @param optionsOrTarget Options for how the deprected decorator should function at runtime.
  */
  export function deprecated(optionsOrTarget?: DeprecatedOptions, maybeKey?: string, maybeDescriptor?: Object): any;
  
  /**
  * Decorator: Enables mixing behaior into a class.
  * @param behavior An object with keys for each method to mix into the target class.
  */
  export function mixin(behavior: Object): any;
  
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  /**
  * Decorator: Creates a protocol.
  * @param name The name of the protocol.
  * @param options The validation function or options object used in configuring the protocol.
  */
  export function protocol(name: string, options?: ((target: any) => string | boolean) | ProtocolOptions): any;
}
}
declare module 'aurelia-metadata' {
export * from '~aurelia-templating-resources~aurelia-metadata/dist/commonjs/aurelia-metadata';
}

// Generated by typings
// Source: node_modules/aurelia-templating-resources/dist/commonjs/aurelia-templating-resources.d.ts
declare module 'aurelia-templating-resources' {
  import * as LogManager from 'aurelia-logging';
  import {
    inject,
    Container
  } from 'aurelia-dependency-injection';
  import {
    BoundViewFactory,
    ViewSlot,
    customAttribute,
    templateController,
    Animator,
    useView,
    customElement,
    bindable,
    ViewResources,
    resource,
    ViewCompileInstruction,
    CompositionEngine,
    noView,
    View,
    TargetInstruction
  } from 'aurelia-templating';
  import {
    createOverrideContext,
    bindingMode,
    EventManager,
    BindingBehavior,
    ValueConverter,
    sourceContext,
    mergeSplice,
    valueConverter,
    ObserverLocator
  } from 'aurelia-binding';
  import {
    DOM,
    FEATURE
  } from 'aurelia-pal';
  import {
    TaskQueue
  } from 'aurelia-task-queue';
  import {
    Loader
  } from 'aurelia-loader';
  import {
    relativeToFile
  } from 'aurelia-path';
  import {
    mixin
  } from 'aurelia-metadata';
  
  /**
  * A strategy is for repeating a template over an iterable or iterable-like object.
  */
  export interface RepeatStrategy {
    instanceChanged(repeat: Repeat, items: any): void;
    instanceMutated(repeat: Repeat, items: any, changes: any): void;
    getCollectionObserver(observerLocator: any, items: any): any;
  }
  
  /**
  * Creates a binding context for decandant elements to bind to.
  */
  export class With {
    
    /**
      * Creates an instance of With.
      * @param viewFactory The factory generating the view.
      * @param viewSlot The slot the view is injected in to.
      */
    constructor(viewFactory: any, viewSlot: any);
    
    /**
      * Binds the With with provided binding context and override context.
      * @param bindingContext The binding context.
      * @param overrideContext An override context for binding.
      */
    bind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Invoked everytime the bound value changes.
      * @param newValue The new value.
      */
    valueChanged(newValue: any): any;
    
    /**
      * Unbinds With
      */
    unbind(): any;
  }
  
  /**
  * Attribute to be placed on any HTML element in a view to emit the View instance
  * to the debug console, giving you insight into the live View instance, including
  * all child views, live bindings, behaviors and more.
  */
  export class ViewSpy {
    
    /**
      * Creates a new instance of ViewSpy.
      */
    constructor();
    
    /**
      * Invoked when the target view is created.
      * @param view The target view.
      */
    created(view: any): any;
    
    /**
      * Invoked when the target view is bound.
      * @param bindingContext The target view's binding context.
      */
    bind(bindingContext: any): any;
    
    /**
      * Invoked when the target element is attached to the DOM.
      */
    attached(): any;
    
    /**
      * Invoked when the target element is detached from the DOM.
      */
    detached(): any;
    
    /**
      * Invoked when the target element is unbound.
      */
    unbind(): any;
  }
  export class UpdateTriggerBindingBehavior {
    static inject: any;
    constructor(eventManager: any);
    bind(binding: any, source: any, ...events: any[]): any;
    unbind(binding: any, source: any): any;
  }
  export class ThrottleBindingBehavior {
    bind(binding: any, source: any, delay?: any): any;
    unbind(binding: any, source: any): any;
  }
  
  /**
  * Binding to conditionally show markup in the DOM based on the value.
  * - different from "if" in that the markup is still added to the DOM, simply not shown.
  */
  export class Show {
    
    /**
      * Creates a new instance of Show.
      * @param element Target element to conditionally show.
      * @param animator The animator that conditionally adds or removes the aurelia-hide css class.
      */
    constructor(element: any, animator: any);
    
    /**
      * Invoked everytime the bound value changes.
      * @param newValue The new value.
      */
    valueChanged(newValue: any): any;
    
    /**
      * Binds the Show attribute.
      */
    bind(bindingContext: any): any;
  }
  
  /**
  * Marks any part of a view to be replacable by the consumer.
  */
  export class Replaceable {
    
    /**
      * @param viewFactory target The factory generating the view.
      * @param viewSlot viewSlot The slot the view is injected in to.
      */
    constructor(viewFactory: any, viewSlot: any);
    
    /**
      * Binds the replaceable to the binding context and override context.
      * @param bindingContext The binding context.
      * @param overrideContext An override context for binding.
      */
    bind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Unbinds the replaceable.
      */
    unbind(): any;
  }
  
  /**
  * Update the override context.
  * @param startIndex index in collection where to start updating.
  */
  export function updateOverrideContexts(views: any, startIndex: any): any;
  
  /**
    * Creates a complete override context.
    * @param data The item's value.
    * @param index The item's index.
    * @param length The collections total length.
    * @param key The key in a key/value pair.
    */
  export function createFullOverrideContext(repeat: any, data: any, index: any, length: any, key: any): any;
  
  /**
  * Updates the override context.
  * @param context The context to be updated.
  * @param index The context's index.
  * @param length The collection's length.
  */
  export function updateOverrideContext(overrideContext: any, index: any, length: any): any;
  
  /**
  * Gets a repeat instruction's source expression.
  */
  export function getItemsSourceExpression(instruction: any, attrName: any): any;
  
  /**
  * Unwraps an expression to expose the inner, pre-converted / behavior-free expression.
  */
  export function unwrapExpression(expression: any): any;
  
  /**
  * Returns whether an expression has the OneTimeBindingBehavior applied.
  */
  export function isOneTime(expression: any): any;
  
  /**
  * Forces a binding instance to reevaluate.
  */
  export function updateOneTimeBinding(binding: any): any;
  
  /**
  * A strategy for repeating a template over null or undefined (does nothing)
  */
  export class NullRepeatStrategy {
    instanceChanged(repeat: any, items: any): any;
    getCollectionObserver(observerLocator: any, items: any): any;
  }
  
  /**
  * Binding to conditionally include or not include template logic depending on returned result
  * - value should be Boolean or will be treated as such (truthy / falsey)
  */
  export class If {
    
    /**
      * Creates an instance of If.
      * @param {BoundViewFactory} viewFactory The factory generating the view
      * @param {ViewSlot} viewSlot The slot the view is injected in to
      */
    constructor(viewFactory: any, viewSlot: any);
    
    /**
      * Binds the if to the binding context and override context
      * @param bindingContext The binding context
      * @param overrideContext An override context for binding.
      */
    bind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Invoked everytime value property changes.
      * @param newValue The new value
      */
    valueChanged(newValue: any): any;
    
    /**
      * Unbinds the if
      */
    unbind(): any;
  }
  
  /**
  * Default Html Sanitizer to prevent script injection.
  */
  export class HTMLSanitizer {
    
    /**
      * Sanitizes the provided input.
      * @param input The input to be sanitized.
      */
    sanitize(input: any): any;
  }
  
  /**
  * Binding to conditionally show markup in the DOM based on the value.
  * - different from "if" in that the markup is still added to the DOM, simply not shown.
  */
  export class Hide {
    
    /**
      * Creates a new instance of Hide.
      * @param element Target element to conditionally hide.
      * @param animator The animator that conditionally adds or removes the aurelia-hide css class.
      */
    constructor(element: any, animator: any);
    
    /**
      * Invoked everytime the bound value changes.
      * @param newValue The new value.
      */
    valueChanged(newValue: any): any;
    
    /**
      * Binds the Hide attribute.
      */
    bind(bindingContext: any): any;
  }
  
  /**
  * CustomAttribute that binds provided DOM element's focus attribute with a property on the viewmodel.
  */
  export class Focus {
    
    /**
      * Creates an instance of Focus.
      * @paramelement Target element on where attribute is placed on.
      * @param taskQueue The TaskQueue instance.
      */
    constructor(element: any, taskQueue: any);
    
    /**
      * Invoked everytime the bound value changes.
      * @param newValue The new value.
      */
    valueChanged(newValue: any): any;
    
    /**
      * Invoked when the attribute is attached to the DOM.
      */
    attached(): any;
    
    /**
      * Invoked when the attribute is detached from the DOM.
      */
    detached(): any;
  }
  export class DebounceBindingBehavior {
    bind(binding: any, source: any, delay?: any): any;
    
    // should not delay initial target update that occurs during bind.
    unbind(binding: any, source: any): any;
  }
  
  /**
  * Used to compose a new view / view-model template or bind to an existing instance.
  */
  export class Compose {
    model: any;
    view: any;
    viewModel: any;
    
    /**
      * Creates an instance of Compose.
      * @param element The Compose element.
      * @param container The dependency injection container instance.
      * @param compositionEngine CompositionEngine instance to compose the element.
      * @param viewSlot The slot the view is injected in to.
      * @param viewResources Collection of resources used to compile the the view.
      * @param taskQueue The TaskQueue instance.
      */
    constructor(element: any, container: any, compositionEngine: any, viewSlot: any, viewResources: any, taskQueue: any);
    
    /**
      * Invoked when the component has been created.
      *
      * @param owningView The view that this component was created inside of.
      */
    created(owningView: View): any;
    
    /**
      * Used to set the bindingContext.
      *
      * @param bindingContext The context in which the view model is executed in.
      * @param overrideContext The context in which the view model is executed in.
      */
    bind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Unbinds the Compose.
      */
    unbind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Invoked everytime the bound model changes.
      * @param newValue The new value.
      * @param oldValue The old value.
      */
    modelChanged(newValue: any, oldValue: any): any;
    
    /**
      * Invoked everytime the bound view changes.
      * @param newValue The new value.
      * @param oldValue The old value.
      */
    viewChanged(newValue: any, oldValue: any): any;
    
    /**
        * Invoked everytime the bound view model changes.
        * @param newValue The new value.
        * @param oldValue The old value.
        */
    viewModelChanged(newValue: any, oldValue: any): any;
  }
  
  /**
  * Attribute to be placed on any element to have it emit the View Compiler's
  * TargetInstruction into the debug console, giving you insight into all the
  * parsed bindings, behaviors and event handers for the targeted element.
  */
  export class CompileSpy {
    
    /**
      * Creates and instanse of CompileSpy.
      * @param element target element on where attribute is placed on.
      * @param instruction instructions for how the target element should be enhanced.
      */
    constructor(element: any, instruction: any);
  }
  export class BindingSignaler {
    signals: any;
    signal(name: string): void;
  }
  export class OneTimeBindingBehavior {
    constructor();
  }
  export class OneWayBindingBehavior {
    constructor();
  }
  export class TwoWayBindingBehavior {
    constructor();
  }
  
  /**
  * Behaviors that do not require the composition lifecycle callbacks when replacing
  * their binding context.
  */
  export const lifecycleOptionalBehaviors: any;
  export function viewsRequireLifecycle(viewFactory: any): any;
  
  /**
  * An abstract base class for elements and attributes that repeat
  * views.
  */
  export class AbstractRepeater {
    constructor(options: any);
    
    /**
       * Returns the number of views the repeater knows about.
       *
       * @return {Number}  the number of views.
       */
    viewCount(): any;
    
    /**
       * Returns all of the repeaters views as an array.
       *
       * @return {Array} The repeater's array of views;
       */
    views(): any;
    
    /**
       * Returns a single view from the repeater at the provided index.
       *
       * @param {Number} index The index of the requested view.
       * @return {View|ViewSlot} The requested view.
       */
    view(index: any): any;
    
    /**
       * Adds a view to the repeater, binding the view to the
       * provided contexts.
       *
       * @param {Object} bindingContext The binding context to bind the new view to.
       * @param {Object} overrideContext A secondary binding context that can override the primary context.
       */
    addView(bindingContext: any, overrideContext: any): any;
    
    /**
       * Inserts a view to the repeater at a specific index, binding the view to the
       * provided contexts.
       *
       * @param {Number} index The index at which to create the new view at.
       * @param {Object} bindingContext The binding context to bind the new view to.
       * @param {Object} overrideContext A secondary binding context that can override the primary context.
       */
    insertView(index: any, bindingContext: any, overrideContext: any): any;
    
    /**
       * Removes all views from the repeater.
       * @param {Boolean} returnToCache Should the view be returned to the view cache?
       * @param {Boolean} skipAnimation Should the removal animation be skipped?
       * @return {Promise|null}
       */
    removeAllViews(returnToCache?: boolean, skipAnimation?: boolean): any;
    
    /**
       * Removes a view from the repeater at a specific index.
       *
       * @param {Number} index The index of the view to be removed.
       * @param {Boolean} returnToCache Should the view be returned to the view cache?
       * @param {Boolean} skipAnimation Should the removal animation be skipped?
       * @return {Promise|null}
       */
    removeView(index: number, returnToCache?: boolean, skipAnimation?: boolean): any;
    
    /**
       * Forces a particular view to update it's bindings, called as part of
       * an in-place processing of items for better performance
       *
       * @param {Object} view the target view for bindings updates
       */
    updateBindings(view: View): any;
  }
  
  /**
  * A strategy for repeating a template over an array.
  */
  export class ArrayRepeatStrategy {
    
    /**
      * Gets an observer for the specified collection.
      * @param observerLocator The observer locator instance.
      * @param items The items to be observed.
      */
    getCollectionObserver(observerLocator: any, items: any): any;
    
    /**
      * Handle the repeat's collection instance changing.
      * @param repeat The repeater instance.
      * @param items The new array instance.
      */
    instanceChanged(repeat: any, items: any): any;
    
    /**
      * Handle the repeat's collection instance mutating.
      * @param repeat The repeat instance.
      * @param array The modified array.
      * @param splices Records of array changes.
      */
    instanceMutated(repeat: any, array: any, splices: any): any;
  }
  
  /**
  * A strategy for repeating a template over a Map.
  */
  export class MapRepeatStrategy {
    
    /**
      * Gets a Map observer.
      * @param items The items to be observed.
      */
    getCollectionObserver(observerLocator: any, items: any): any;
    
    /**
      * Process the provided Map entries.
      * @param items The entries to process.
      */
    instanceChanged(repeat: any, items: any): any;
    
    /**
      * Handle changes in a Map collection.
      * @param map The underlying Map collection.
      * @param records The change records.
      */
    instanceMutated(repeat: any, map: any, records: any): any;
  }
  
  /**
  * A strategy for repeating a template over a number.
  */
  export class NumberRepeatStrategy {
    
    /**
      * Return the strategies collection observer. In this case none.
      */
    getCollectionObserver(): any;
    
    /**
      * Process the provided Number.
      * @param value The Number of how many time to iterate.
      */
    instanceChanged(repeat: any, value: any): any;
  }
  
  /**
  * A strategy for repeating a template over a Set.
  */
  export class SetRepeatStrategy {
    
    /**
      * Gets a Set observer.
      * @param items The items to be observed.
      */
    getCollectionObserver(observerLocator: any, items: any): any;
    
    /**
      * Process the provided Set entries.
      * @param items The entries to process.
      */
    instanceChanged(repeat: any, items: any): any;
    
    /**
      * Handle changes in a Set collection.
      * @param map The underlying Set collection.
      * @param records The change records.
      */
    instanceMutated(repeat: any, set: any, records: any): any;
  }
  
  /**
  * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.
  */
  export class SanitizeHTMLValueConverter {
    
    /**
       * Creates an instanse of the value converter.
       * @param sanitizer The html sanitizer.
       */
    constructor(sanitizer: any);
    
    /**
      * Process the provided markup that flows to the view.
      * @param untrustedMarkup The untrusted markup to be sanitized.
      */
    toView(untrustedMarkup: any): any;
  }
  export class SignalBindingBehavior {
    static inject(): any;
    signals: any;
    constructor(bindingSignaler: any);
    bind(binding: any, source: any): any;
    unbind(binding: any, source: any): any;
  }
  
  /**
  * Locates the best strategy to best repeating a template over different types of collections.
  * Custom strategies can be plugged in as well.
  */
  /**
  * Locates the best strategy to best repeating a template over different types of collections.
  * Custom strategies can be plugged in as well.
  */
  export class RepeatStrategyLocator {
    
    /**
      * Creates a new RepeatStrategyLocator.
      */
    constructor();
    
    /**
      * Adds a repeat strategy to be located when repeating a template over different collection types.
      * @param strategy A repeat strategy that can iterate a specific collection type.
      */
    addStrategy(matcher: ((items: any) => boolean), strategy: RepeatStrategy): any;
    
    /**
      * Gets the best strategy to handle iteration.
      */
    getStrategy(items: any): RepeatStrategy;
  }
  
  /*eslint no-loop-func:0, no-unused-vars:0*/
  /**
  * Binding to iterate over iterable objects (Array, Map and Number) to genereate a template for each iteration.
  */
  export class Repeat extends AbstractRepeater {
    items: any;
    local: any;
    key: any;
    value: any;
    
    /**
     * Creates an instance of Repeat.
     * @param viewFactory The factory generating the view
     * @param instruction The instructions for how the element should be enhanced.
     * @param viewResources Collection of resources used to compile the the views.
     * @param viewSlot The slot the view is injected in to.
     * @param observerLocator The observer locator instance.
     * @param collectionStrategyLocator The strategy locator to locate best strategy to iterate the collection.
     */
    constructor(viewFactory: any, instruction: any, viewSlot: any, viewResources: any, observerLocator: any, strategyLocator: any);
    call(context: any, changes: any): any;
    
    /**
      * Binds the repeat to the binding context and override context.
      * @param bindingContext The binding context.
      * @param overrideContext An override context for binding.
      */
    bind(bindingContext: any, overrideContext: any): any;
    
    /**
      * Unbinds the repeat
      */
    unbind(): any;
    
    /**
      * Invoked everytime the item property changes.
      */
    itemsChanged(): any;
    
    /**
      * Invoked when the underlying collection changes.
      */
    handleCollectionMutated(collection: any, changes: any): any;
    
    /**
      * Invoked when the underlying inner collection changes.
      */
    handleInnerCollectionMutated(collection: any, changes: any): any;
    
    // @override AbstractRepeater
    viewCount(): any;
    views(): any;
    view(index: any): any;
    addView(bindingContext: any, overrideContext: any): any;
    insertView(index: any, bindingContext: any, overrideContext: any): any;
    removeAllViews(returnToCache: any, skipAnimation: any): any;
    removeView(index: any, returnToCache: any, skipAnimation: any): any;
    updateBindings(view: View): any;
  }
}